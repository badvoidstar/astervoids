<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Astervoids</title>
    <style>
        /* ============================================
           STYLES - Minimal CSS for game presentation
           ============================================ */
        
        /* Reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Dark background to match classic arcade feel */
        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile */
            font-family: 'Courier New', monospace;
            overflow: hidden;
            touch-action: none; /* Prevent browser gestures */
        }

        /* Game container for canvas and HUD positioning */
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile */
            max-width: 100%;
            max-height: 100%;
        }

        /* Canvas with subtle border - fills container */
        #game {
            display: block;
            width: 100%;
            height: 100%;
            border: none;
        }

        /* HUD overlay for score, lives, and wave info */
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            color: #fff;
            font-size: 18px;
            pointer-events: none;
        }

        /* Instructions shown at bottom */
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 0;
            right: 0;
            text-align: center;
            color: #666;
            font-size: 12px;
            pointer-events: none;
        }

        /* Pause menu overlay */
        #pause-menu {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
        }

        #pause-menu.visible {
            display: flex;
        }

        #pause-menu h1 {
            font-size: 48px;
            margin-bottom: 30px;
            letter-spacing: 4px;
        }

        #pause-menu .menu-item {
            font-size: 20px;
            margin: 10px 0;
            color: #888;
        }

        #pause-menu .menu-item span {
            color: #fff;
        }

        /* Mobile touch controls */
        #mobile-controls {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .touch-enabled #mobile-controls {
            display: block;
        }

        .touch-enabled #instructions {
            display: none;
        }

        .touch-btn {
            position: absolute;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.4);
            color: rgba(255, 255, 255, 0.7);
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        .touch-btn:active, .touch-btn.active {
            background: rgba(255, 255, 255, 0.35);
            border-color: rgba(255, 255, 255, 0.8);
        }

        /* Left side - movement controls */
        #touch-left {
            width: 70px;
            height: 70px;
            bottom: 100px;
            left: 20px;
        }

        #touch-right {
            width: 70px;
            height: 70px;
            bottom: 100px;
            left: 110px;
        }

        #touch-thrust {
            width: 80px;
            height: 80px;
            bottom: 20px;
            left: 60px;
        }

        /* Right side - action controls */
        #touch-fire {
            width: 90px;
            height: 90px;
            bottom: 40px;
            right: 30px;
        }

        #touch-pause {
            width: 50px;
            height: 50px;
            top: 50px;
            right: 10px;
            font-size: 18px;
        }

        /* Restart button for game over on mobile */
        #touch-restart {
            width: 120px;
            height: 50px;
            border-radius: 25px;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            display: none;
        }

        .touch-enabled #touch-restart.visible {
            display: flex;
        }
    </style>
</head>
<body>
    <!-- Game Container: holds canvas and overlay elements -->
    <div id="game-container">
        <canvas id="game" width="800" height="600"></canvas>
        
        <!-- HUD: displays game stats -->
        <div id="hud">
            <span id="score">Score: 0</span>
            <span id="wave">Wave: 1</span>
            <span id="lives">Lives: 3</span>
        </div>
        
        <!-- Instructions: control hints -->
        <div id="instructions">
            Arrow Keys or WASD to move | SPACE to shoot | ESC to pause
        </div>

        <!-- Pause menu overlay -->
        <div id="pause-menu">
            <h1>PAUSED</h1>
            <div class="menu-item"><span>ESC</span> or <span>P</span> - Resume</div>
            <div class="menu-item"><span>ENTER</span> - Restart Game</div>
            <div class="menu-item"><span>Arrow Keys</span> / <span>WASD</span> - Move</div>
            <div class="menu-item"><span>SPACE</span> - Shoot</div>
        </div>

        <!-- Mobile touch controls -->
        <div id="mobile-controls">
            <div id="touch-left" class="touch-btn">◀</div>
            <div id="touch-right" class="touch-btn">▶</div>
            <div id="touch-thrust" class="touch-btn">▲</div>
            <div id="touch-fire" class="touch-btn">FIRE</div>
            <div id="touch-pause" class="touch-btn">❚❚</div>
            <div id="touch-restart" class="touch-btn">RESTART</div>
        </div>
    </div>

    <script>
    /* ================================================================
       ASTERVOIDS GAME
       A single-file HTML5 Canvas implementation following best practices
       ================================================================ */

    // ============================================
    // SECTION 0: AUDIO SYSTEM
    // Web Audio API sound generation for classic arcade sounds
    // ============================================
    
    const AudioSystem = {
        ctx: null,
        enabled: true,
        masterVolume: 0.3,
        
        // Initialize the audio context (must be called after user interaction)
        init() {
            if (this.ctx) return;
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        },
        
        // Resume audio context if suspended (browser autoplay policy)
        resume() {
            if (this.ctx && this.ctx.state === 'suspended') {
                this.ctx.resume();
            }
        },
        
        // Create a gain node with specified volume
        createGain(volume = 1) {
            const gain = this.ctx.createGain();
            gain.gain.value = volume * this.masterVolume;
            gain.connect(this.ctx.destination);
            return gain;
        },
        
        // Ship thrust sound - continuous low rumble
        thrustSound: {
            oscillator: null,
            noiseNode: null,
            gainNode: null,
            
            start() {
                if (!AudioSystem.ctx || !AudioSystem.enabled) return;
                if (this.oscillator) return; // Already playing
                
                const ctx = AudioSystem.ctx;
                
                // Create noise buffer for thrust
                const bufferSize = ctx.sampleRate * 0.5;
                const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                
                // Noise source
                this.noiseNode = ctx.createBufferSource();
                this.noiseNode.buffer = noiseBuffer;
                this.noiseNode.loop = true;
                
                // Low-pass filter for rumble
                const filter = ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 150;
                
                // Gain for volume control
                this.gainNode = ctx.createGain();
                this.gainNode.gain.value = 0.15 * AudioSystem.masterVolume;
                
                // Connect nodes
                this.noiseNode.connect(filter);
                filter.connect(this.gainNode);
                this.gainNode.connect(ctx.destination);
                
                this.noiseNode.start();
            },
            
            stop() {
                if (this.noiseNode) {
                    try {
                        this.noiseNode.stop();
                    } catch (e) {}
                    this.noiseNode = null;
                }
                this.gainNode = null;
            }
        },
        
        // Ship fire sound - classic pew
        playFire() {
            if (!this.ctx || !this.enabled) return;
            
            const ctx = this.ctx;
            const now = ctx.currentTime;
            
            // Main tone
            const osc = ctx.createOscillator();
            osc.type = 'square';
            osc.frequency.setValueAtTime(880, now);
            osc.frequency.exponentialRampToValueAtTime(110, now + 0.1);
            
            const gain = this.createGain(0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
            
            osc.connect(gain);
            osc.start(now);
            osc.stop(now + 0.1);
        },
        
        // Asteroid explosion - different pitch based on size
        playExplosion(size = 'large') {
            if (!this.ctx || !this.enabled) return;
            
            const ctx = this.ctx;
            const now = ctx.currentTime;
            
            // Frequency based on asteroid size (smaller = higher pitch)
            const baseFreq = size === 'large' ? 60 : size === 'medium' ? 90 : 120;
            const duration = size === 'large' ? 0.4 : size === 'medium' ? 0.3 : 0.2;
            
            // Noise burst for explosion
            const bufferSize = ctx.sampleRate * duration;
            const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            
            const noise = ctx.createBufferSource();
            noise.buffer = noiseBuffer;
            
            // Band-pass filter
            const filter = ctx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.value = baseFreq * 3;
            filter.Q.value = 1;
            
            const gain = this.createGain(0.25);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            noise.connect(filter);
            filter.connect(gain);
            noise.start(now);
            noise.stop(now + duration);
            
            // Add a low thump
            const osc = ctx.createOscillator();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(baseFreq, now);
            osc.frequency.exponentialRampToValueAtTime(20, now + duration * 0.5);
            
            const oscGain = this.createGain(0.3);
            oscGain.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.5);
            
            osc.connect(oscGain);
            osc.start(now);
            osc.stop(now + duration * 0.5);
        },
        
        // Ship explosion - dramatic death sound
        playShipExplosion() {
            if (!this.ctx || !this.enabled) return;
            
            const ctx = this.ctx;
            const now = ctx.currentTime;
            
            // Multiple descending tones
            for (let i = 0; i < 3; i++) {
                const osc = ctx.createOscillator();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(400 - i * 100, now + i * 0.05);
                osc.frequency.exponentialRampToValueAtTime(30, now + 0.8);
                
                const gain = this.createGain(0.2);
                gain.gain.setValueAtTime(0.2 * this.masterVolume, now + i * 0.05);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
                
                osc.connect(gain);
                osc.start(now + i * 0.05);
                osc.stop(now + 0.8);
            }
            
            // Noise burst
            const bufferSize = ctx.sampleRate * 0.6;
            const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            
            const noise = ctx.createBufferSource();
            noise.buffer = noiseBuffer;
            
            const filter = ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(2000, now);
            filter.frequency.exponentialRampToValueAtTime(100, now + 0.6);
            
            const noiseGain = this.createGain(0.3);
            noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
            
            noise.connect(filter);
            filter.connect(noiseGain);
            noise.start(now);
            noise.stop(now + 0.6);
        },
        
        // Extra life sound
        playExtraLife() {
            if (!this.ctx || !this.enabled) return;
            
            const ctx = this.ctx;
            const now = ctx.currentTime;
            
            const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
            
            notes.forEach((freq, i) => {
                const osc = ctx.createOscillator();
                osc.type = 'square';
                osc.frequency.value = freq;
                
                const gain = this.createGain(0.1);
                gain.gain.setValueAtTime(0, now + i * 0.1);
                gain.gain.linearRampToValueAtTime(0.1 * this.masterVolume, now + i * 0.1 + 0.02);
                gain.gain.linearRampToValueAtTime(0, now + i * 0.1 + 0.15);
                
                osc.connect(gain);
                osc.start(now + i * 0.1);
                osc.stop(now + i * 0.1 + 0.15);
            });
        },
        
        // Classic Astervoids background beat - two alternating tones
        beat: {
            intervalId: null,
            beatIndex: 0,
            tempo: 1000, // ms between beats
            minTempo: 150,
            maxTempo: 1000,
            
            start() {
                if (this.intervalId) return;
                this.beatIndex = 0;
                this.tempo = this.maxTempo;
                this.scheduleBeat();
            },
            
            stop() {
                if (this.intervalId) {
                    clearTimeout(this.intervalId);
                    this.intervalId = null;
                }
            },
            
            scheduleBeat() {
                this.intervalId = setTimeout(() => {
                    this.playBeat();
                    this.scheduleBeat();
                }, this.tempo);
            },
            
            playBeat() {
                if (!AudioSystem.ctx || !AudioSystem.enabled) return;
                
                const ctx = AudioSystem.ctx;
                const now = ctx.currentTime;
                
                // Alternating low tones (like original Astervoids)
                const freq = this.beatIndex % 2 === 0 ? 55 : 50; // A1 and ~G#1
                
                const osc = ctx.createOscillator();
                osc.type = 'triangle';
                osc.frequency.value = freq;
                
                const gain = AudioSystem.createGain(0.25);
                gain.gain.setValueAtTime(0.25 * AudioSystem.masterVolume, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                
                osc.connect(gain);
                osc.start(now);
                osc.stop(now + 0.15);
                
                this.beatIndex++;
            },
            
            // Adjust tempo based on number of astervoids (fewer = faster)
            updateTempo(asteroidCount, maxAstervoids) {
                if (maxAstervoids <= 0) maxAstervoids = 1;
                const ratio = asteroidCount / maxAstervoids;
                this.tempo = this.minTempo + (this.maxTempo - this.minTempo) * ratio;
            }
        },
        
        // Saucer sound (for future use)
        saucerSound: {
            oscillator: null,
            gainNode: null,
            
            start(isSmall = false) {
                if (!AudioSystem.ctx || !AudioSystem.enabled) return;
                if (this.oscillator) return;
                
                const ctx = AudioSystem.ctx;
                
                this.oscillator = ctx.createOscillator();
                this.oscillator.type = 'sawtooth';
                this.oscillator.frequency.value = isSmall ? 1200 : 800;
                
                // LFO for warble effect
                const lfo = ctx.createOscillator();
                lfo.frequency.value = isSmall ? 8 : 5;
                
                const lfoGain = ctx.createGain();
                lfoGain.gain.value = isSmall ? 100 : 60;
                
                lfo.connect(lfoGain);
                lfoGain.connect(this.oscillator.frequency);
                
                this.gainNode = AudioSystem.createGain(0.08);
                
                this.oscillator.connect(this.gainNode);
                
                this.oscillator.start();
                lfo.start();
            },
            
            stop() {
                if (this.oscillator) {
                    try {
                        this.oscillator.stop();
                    } catch (e) {}
                    this.oscillator = null;
                }
                this.gainNode = null;
            }
        },
        
        // New wave sound
        playNewWave() {
            if (!this.ctx || !this.enabled) return;
            
            const ctx = this.ctx;
            const now = ctx.currentTime;
            
            // Ascending tone
            const osc = ctx.createOscillator();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.exponentialRampToValueAtTime(600, now + 0.3);
            
            const gain = this.createGain(0.15);
            gain.gain.setValueAtTime(0.15 * this.masterVolume, now);
            gain.gain.linearRampToValueAtTime(0.15 * this.masterVolume, now + 0.2);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
            
            osc.connect(gain);
            osc.start(now);
            osc.stop(now + 0.4);
        }
    };

    // ============================================
    // SECTION 1: CONFIGURATION
    // All tunable game parameters in one place
    // ============================================
    const CONFIG = {
        // Base design dimensions (used for scaling)
        BASE_WIDTH: 800,            // Reference width for scaling
        BASE_HEIGHT: 600,           // Reference height for scaling
        
        // Timing settings
        TARGET_FPS: 60,             // Target frame rate for physics
        
        // Ship settings
        SHIP_SIZE: 15,              // Ship triangle size in pixels
        SHIP_THRUST: 0.15,          // Acceleration when thrusting
        SHIP_FRICTION: 0.99,        // Velocity decay (1 = no friction)
        SHIP_TURN_SPEED: 0.08,      // Rotation speed in radians per frame
        SHIP_MAX_SPEED: 8,          // Maximum velocity magnitude
        
        // Bullet settings
        BULLET_SPEED: 10,           // Bullet travel speed
        BULLET_LIFETIME: 60,        // Frames before bullet expires
        BULLET_RADIUS: 2,           // Bullet size for collision
        MAX_BULLETS: 10,            // Maximum bullets on screen
        SHOOT_COOLDOWN: 10,         // Frames between shots
        
        // Asteroid settings
        ASTEROID_BASE_COUNT: 1,     // Starting astervoids in wave 1
        ASTEROID_BASE_SPEED: 1.5,   // Base asteroid speed
        ASTEROID_SPEED_VARIANCE: 1, // Random speed variation
        ASTEROID_VERTICES: 10,      // Number of vertices per asteroid
        ASTEROID_JAGGEDNESS: 0.4,   // Shape irregularity (0-1)
        MIN_ASTEROID_RADIUS: 15,    // Astervoids smaller than this won't split
        INITIAL_ASTEROID_RADIUS: 50,// Starting asteroid size
        
        // Asteroid splitting
        SPLIT_COUNT: 2,             // Always split into 2 pieces
        MIN_SPLIT_RATIO: 0.1,       // Smallest piece is at least 10% of original
        
        // Scoring (points awarded based on asteroid size)
        POINTS_LARGE: 20,           // Points for large astervoids
        POINTS_MEDIUM: 50,          // Points for medium astervoids
        POINTS_SMALL: 100,          // Points for small astervoids
        
        // Game settings
        STARTING_LIVES: 3,          // Lives at game start
        INVULNERABILITY_TIME: 180,  // Frames of invulnerability after respawn
        WAVE_DELAY: 120,            // Frames to wait between waves
        
        // Wave progression
        WAVE_ASTEROID_INCREMENT: 1, // Extra astervoids per wave
        WAVE_SPEED_MULTIPLIER: 1.1, // Speed increase per wave
        MAX_SPEED_MULTIPLIER: 2.0,  // Cap on speed scaling
        
        // Visual settings
        STROKE_COLOR: '#fff',       // Primary drawing color
        THRUST_COLOR: '#f80',       // Thrust flame color
        INVULN_BLINK_RATE: 10       // Blink frequency when invulnerable
    };

    // ============================================
    // SECTION 2: UTILITY FUNCTIONS
    // Helper functions used throughout the game
    // ============================================

    /**
     * Resize the canvas to fill the window while maintaining game state
     * Scales all game entity positions proportionally
     */
    function resizeCanvas() {
        const container = document.getElementById('game-container');
        const newWidth = container.clientWidth;
        const newHeight = container.clientHeight;
        
        // Store old dimensions for scaling
        const oldWidth = canvas.width || CONFIG.BASE_WIDTH;
        const oldHeight = canvas.height || CONFIG.BASE_HEIGHT;
        
        // Only resize if dimensions actually changed
        if (newWidth === oldWidth && newHeight === oldHeight) return;
        
        // Calculate scale factors
        const scaleX = newWidth / oldWidth;
        const scaleY = newHeight / oldHeight;
        
        // Update canvas dimensions
        canvas.width = newWidth;
        canvas.height = newHeight;
        
        // Scale all game entity positions if game is initialized
        if (game.ship) {
            game.ship.x *= scaleX;
            game.ship.y *= scaleY;
        }
        
        if (game.astervoids) {
            game.astervoids.forEach(asteroid => {
                asteroid.x *= scaleX;
                asteroid.y *= scaleY;
            });
        }
        
        if (game.bullets) {
            game.bullets.forEach(bullet => {
                bullet.x *= scaleX;
                bullet.y *= scaleY;
            });
        }
    }

    /**
     * Get the scale factor relative to base design dimensions
     * Used for scaling visual elements like ship size
     * @returns {number} Scale factor
     */
    function getScaleFactor() {
        const scaleX = canvas.width / CONFIG.BASE_WIDTH;
        const scaleY = canvas.height / CONFIG.BASE_HEIGHT;
        return Math.min(scaleX, scaleY);
    }

    /**
     * Wraps a position to the opposite side of the canvas
     * Creates the classic "wrap-around" effect
     * @param {number} value - Current position
     * @param {number} max - Canvas dimension
     * @returns {number} Wrapped position
     */
    function wrapValue(value, max) {
        if (value < 0) return max + value;
        if (value > max) return value - max;
        return value;
    }

    /**
     * Calculates distance between two points
     * @param {number} x1, y1 - First point
     * @param {number} x2, y2 - Second point
     * @returns {number} Distance
     */
    function distance(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
    }

    /**
     * Generates a random number between min and max
     * @param {number} min - Minimum value
     * @param {number} max - Maximum value
     * @returns {number} Random value in range
     */
    function randomRange(min, max) {
        return Math.random() * (max - min) + min;
    }

    /**
     * Point-in-polygon test using ray casting algorithm
     * Used for collision detection with irregular asteroid shapes
     * @param {object} point - {x, y} coordinates
     * @param {array} vertices - Array of {x, y} polygon vertices
     * @returns {boolean} True if point is inside polygon
     */
    function pointInPolygon(point, vertices) {
        let inside = false;
        const n = vertices.length;
        
        for (let i = 0, j = n - 1; i < n; j = i++) {
            const xi = vertices[i].x, yi = vertices[i].y;
            const xj = vertices[j].x, yj = vertices[j].y;
            
            // Check if ray from point crosses this edge
            if (((yi > point.y) !== (yj > point.y)) &&
                (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi)) {
                inside = !inside;
            }
        }
        
        return inside;
    }

    /**
     * Circle-to-polygon collision detection
     * Tests if a circle intersects with a polygon
     * @param {object} circle - {x, y, radius}
     * @param {array} vertices - Array of {x, y} polygon vertices
     * @returns {boolean} True if collision detected
     */
    function circlePolygonCollision(circle, vertices) {
        // First check if circle center is inside polygon
        if (pointInPolygon({x: circle.x, y: circle.y}, vertices)) {
            return true;
        }
        
        // Then check if circle intersects any polygon edge
        const n = vertices.length;
        for (let i = 0; i < n; i++) {
            const v1 = vertices[i];
            const v2 = vertices[(i + 1) % n];
            
            // Find closest point on edge to circle center
            const edgeX = v2.x - v1.x;
            const edgeY = v2.y - v1.y;
            const edgeLength = Math.sqrt(edgeX * edgeX + edgeY * edgeY);
            
            // Normalize edge vector
            const edgeNormX = edgeX / edgeLength;
            const edgeNormY = edgeY / edgeLength;
            
            // Vector from v1 to circle center
            const toCircleX = circle.x - v1.x;
            const toCircleY = circle.y - v1.y;
            
            // Project onto edge
            let projection = toCircleX * edgeNormX + toCircleY * edgeNormY;
            projection = Math.max(0, Math.min(edgeLength, projection));
            
            // Closest point on edge
            const closestX = v1.x + edgeNormX * projection;
            const closestY = v1.y + edgeNormY * projection;
            
            // Check distance from closest point to circle center
            if (distance(closestX, closestY, circle.x, circle.y) <= circle.radius) {
                return true;
            }
        }
        
        return false;
    }

    // ============================================
    // SECTION 3: GAME ENTITY CLASSES
    // Ship, Asteroid, and Bullet definitions
    // ============================================

    /**
     * Ship Class
     * The player-controlled spacecraft
     */
    class Ship {
        constructor(x, y) {
            this.x = x;                    // X position
            this.y = y;                    // Y position
            this.angle = -Math.PI / 2;     // Facing up initially
            this.velocityX = 0;            // Horizontal velocity
            this.velocityY = 0;            // Vertical velocity
            this.thrusting = false;        // Is thrust active?
            this.invulnerable = 0;         // Invulnerability frames remaining
            this.shootCooldown = 0;        // Frames until can shoot again
        }

        /**
         * Update ship state based on physics and input
         * @param {object} canvas - Canvas element for wrapping
         * @param {number} dt - Delta time multiplier (1.0 = 60fps)
         */
        update(canvas, dt = 1) {
            // Apply friction to slow down gradually (adjust for delta time)
            const friction = Math.pow(CONFIG.SHIP_FRICTION, dt);
            this.velocityX *= friction;
            this.velocityY *= friction;
            
            // Apply thrust in facing direction
            if (this.thrusting) {
                this.velocityX += Math.cos(this.angle) * CONFIG.SHIP_THRUST * dt;
                this.velocityY += Math.sin(this.angle) * CONFIG.SHIP_THRUST * dt;
            }
            
            // Limit to max speed
            const speed = Math.sqrt(this.velocityX ** 2 + this.velocityY ** 2);
            if (speed > CONFIG.SHIP_MAX_SPEED) {
                this.velocityX = (this.velocityX / speed) * CONFIG.SHIP_MAX_SPEED;
                this.velocityY = (this.velocityY / speed) * CONFIG.SHIP_MAX_SPEED;
            }
            
            // Update position
            this.x += this.velocityX * dt;
            this.y += this.velocityY * dt;
            
            // Wrap around screen edges
            this.x = wrapValue(this.x, canvas.width);
            this.y = wrapValue(this.y, canvas.height);
            
            // Decrement timers (adjusted for delta time)
            if (this.invulnerable > 0) this.invulnerable -= dt;
            if (this.shootCooldown > 0) this.shootCooldown -= dt;
        }

        /**
         * Get the ship's triangle vertices in world coordinates
         * Used for both rendering and collision detection
         * @returns {array} Array of {x, y} vertices
         */
        getVertices() {
            const size = CONFIG.SHIP_SIZE;
            return [
                // Nose (front point)
                {
                    x: this.x + Math.cos(this.angle) * size,
                    y: this.y + Math.sin(this.angle) * size
                },
                // Left wing
                {
                    x: this.x + Math.cos(this.angle + Math.PI * 0.8) * size * 0.7,
                    y: this.y + Math.sin(this.angle + Math.PI * 0.8) * size * 0.7
                },
                // Right wing
                {
                    x: this.x + Math.cos(this.angle - Math.PI * 0.8) * size * 0.7,
                    y: this.y + Math.sin(this.angle - Math.PI * 0.8) * size * 0.7
                }
            ];
        }

        /**
         * Draw the ship using vector lines
         * @param {CanvasRenderingContext2D} ctx - Canvas context
         */
        draw(ctx) {
            // Skip drawing if blinking during invulnerability
            if (this.invulnerable > 0 && 
                Math.floor(this.invulnerable / CONFIG.INVULN_BLINK_RATE) % 2 === 0) {
                return;
            }
            
            const vertices = this.getVertices();
            
            // Draw ship triangle
            ctx.strokeStyle = CONFIG.STROKE_COLOR;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            ctx.lineTo(vertices[1].x, vertices[1].y);
            ctx.lineTo(vertices[2].x, vertices[2].y);
            ctx.closePath();
            ctx.stroke();
            
            // Draw thrust flame when accelerating
            if (this.thrusting) {
                ctx.strokeStyle = CONFIG.THRUST_COLOR;
                ctx.beginPath();
                
                // Flame base points (between wings)
                const flameBase1 = {
                    x: this.x + Math.cos(this.angle + Math.PI * 0.9) * CONFIG.SHIP_SIZE * 0.4,
                    y: this.y + Math.sin(this.angle + Math.PI * 0.9) * CONFIG.SHIP_SIZE * 0.4
                };
                const flameBase2 = {
                    x: this.x + Math.cos(this.angle - Math.PI * 0.9) * CONFIG.SHIP_SIZE * 0.4,
                    y: this.y + Math.sin(this.angle - Math.PI * 0.9) * CONFIG.SHIP_SIZE * 0.4
                };
                
                // Flame tip (flickers randomly)
                const flameLength = CONFIG.SHIP_SIZE * (0.8 + Math.random() * 0.4);
                const flameTip = {
                    x: this.x + Math.cos(this.angle + Math.PI) * flameLength,
                    y: this.y + Math.sin(this.angle + Math.PI) * flameLength
                };
                
                ctx.moveTo(flameBase1.x, flameBase1.y);
                ctx.lineTo(flameTip.x, flameTip.y);
                ctx.lineTo(flameBase2.x, flameBase2.y);
                ctx.stroke();
            }
        }

        /**
         * Fire a bullet from the ship's nose
         * @returns {Bullet|null} New bullet or null if on cooldown
         */
        shoot() {
            if (this.shootCooldown > 0) return null;
            
            this.shootCooldown = CONFIG.SHOOT_COOLDOWN;
            
            // Play fire sound
            AudioSystem.playFire();
            
            // Spawn bullet at ship's nose
            const nose = this.getVertices()[0];
            return new Bullet(
                nose.x,
                nose.y,
                Math.cos(this.angle) * CONFIG.BULLET_SPEED,
                Math.sin(this.angle) * CONFIG.BULLET_SPEED
            );
        }

        /**
         * Reset ship to center of screen
         * @param {object} canvas - Canvas element
         */
        reset(canvas) {
            this.x = canvas.width / 2;
            this.y = canvas.height / 2;
            this.angle = -Math.PI / 2;
            this.velocityX = 0;
            this.velocityY = 0;
            this.invulnerable = CONFIG.INVULNERABILITY_TIME;
        }
    }

    /**
     * Asteroid Class
     * Space rocks that the player must destroy
     */
    class Asteroid {
        constructor(x, y, radius, velocityX, velocityY) {
            this.x = x;                    // X position
            this.y = y;                    // Y position
            this.radius = radius;          // Size (collision radius)
            this.velocityX = velocityX;    // Horizontal velocity
            this.velocityY = velocityY;    // Vertical velocity
            this.angle = Math.random() * Math.PI * 2;  // Random rotation
            this.rotationSpeed = randomRange(-0.02, 0.02);  // Spin rate
            this.vertices = this.generateShape();  // Irregular polygon
        }

        /**
         * Generate an irregular polygon shape
         * Creates the classic jagged asteroid look
         * @returns {array} Array of {x, y} vertices (relative to center)
         */
        generateShape() {
            const vertices = [];
            const vertexCount = CONFIG.ASTEROID_VERTICES;
            
            for (let i = 0; i < vertexCount; i++) {
                const angle = (i / vertexCount) * Math.PI * 2;
                // Vary radius for jagged appearance
                const variance = 1 - CONFIG.ASTEROID_JAGGEDNESS + 
                                 Math.random() * CONFIG.ASTEROID_JAGGEDNESS * 2;
                vertices.push({
                    angle: angle,
                    distance: this.radius * variance
                });
            }
            
            return vertices;
        }

        /**
         * Get vertices in world coordinates (accounting for position and rotation)
         * @returns {array} Array of {x, y} world-space vertices
         */
        getWorldVertices() {
            return this.vertices.map(v => ({
                x: this.x + Math.cos(v.angle + this.angle) * v.distance,
                y: this.y + Math.sin(v.angle + this.angle) * v.distance
            }));
        }

        /**
         * Update asteroid position and rotation
         * @param {object} canvas - Canvas element for wrapping
         * @param {number} dt - Delta time multiplier (1.0 = 60fps)
         */
        update(canvas, dt = 1) {
            // Move asteroid
            this.x += this.velocityX * dt;
            this.y += this.velocityY * dt;
            
            // Rotate
            this.angle += this.rotationSpeed * dt;
            
            // Wrap around screen edges
            this.x = wrapValue(this.x, canvas.width);
            this.y = wrapValue(this.y, canvas.height);
        }

        /**
         * Draw asteroid as a vector polygon
         * @param {CanvasRenderingContext2D} ctx - Canvas context
         */
        draw(ctx) {
            const worldVerts = this.getWorldVertices();
            
            ctx.strokeStyle = CONFIG.STROKE_COLOR;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(worldVerts[0].x, worldVerts[0].y);
            
            for (let i = 1; i < worldVerts.length; i++) {
                ctx.lineTo(worldVerts[i].x, worldVerts[i].y);
            }
            
            ctx.closePath();
            ctx.stroke();
        }

        /**
         * Get points awarded for destroying this asteroid
         * Smaller astervoids = more points
         * @returns {number} Point value
         */
        getPoints() {
            if (this.radius >= 40) return CONFIG.POINTS_LARGE;
            if (this.radius >= 25) return CONFIG.POINTS_MEDIUM;
            return CONFIG.POINTS_SMALL;
        }
    }

    /**
     * Bullet Class
     * Projectiles fired by the ship
     */
    class Bullet {
        constructor(x, y, velocityX, velocityY) {
            this.x = x;                    // X position
            this.y = y;                    // Y position
            this.velocityX = velocityX;    // Horizontal velocity
            this.velocityY = velocityY;    // Vertical velocity
            this.lifetime = CONFIG.BULLET_LIFETIME;  // Frames until expiry
        }

        /**
         * Update bullet position and lifetime
         * @param {object} canvas - Canvas element for wrapping
         * @param {number} dt - Delta time multiplier (1.0 = 60fps)
         */
        update(canvas, dt = 1) {
            this.x += this.velocityX * dt;
            this.y += this.velocityY * dt;
            
            // Wrap around screen edges
            this.x = wrapValue(this.x, canvas.width);
            this.y = wrapValue(this.y, canvas.height);
            
            // Decrement lifetime (adjusted for delta time)
            this.lifetime -= dt;
        }

        /**
         * Draw bullet as a small circle
         * @param {CanvasRenderingContext2D} ctx - Canvas context
         */
        draw(ctx) {
            ctx.strokeStyle = CONFIG.STROKE_COLOR;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(this.x, this.y, CONFIG.BULLET_RADIUS, 0, Math.PI * 2);
            ctx.stroke();
        }

        /**
         * Check if bullet has expired
         * @returns {boolean} True if bullet should be removed
         */
        isExpired() {
            return this.lifetime <= 0;
        }
    }

    // ============================================
    // SECTION 4: GAME STATE
    // Variables tracking current game status
    // ============================================

    // Canvas and context references
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // HUD element references
    const scoreDisplay = document.getElementById('score');
    const waveDisplay = document.getElementById('wave');
    const livesDisplay = document.getElementById('lives');

    // Game state object
    const game = {
        ship: null,           // Player ship instance
        astervoids: [],        // Active astervoids
        bullets: [],          // Active bullets
        score: 0,             // Current score
        lives: 0,             // Remaining lives
        wave: 0,              // Current wave number
        state: 'playing',     // 'playing', 'respawning', 'gameover', 'waveDelay', 'paused'
        waveDelayTimer: 0,    // Countdown for wave transition
        speedMultiplier: 1,   // Current speed scaling
        previousState: null,  // State before pausing (to resume correctly)
        lastFrameTime: 0      // Timestamp of last frame for delta time
    };

    // Pause menu element reference
    const pauseMenu = document.getElementById('pause-menu');

    // Input tracking
    const keys = {};
    
    // Touch input tracking (mirrors keys for mobile)
    const touch = {
        left: false,
        right: false,
        thrust: false,
        fire: false
    };

    // ============================================
    // SECTION 5: GAME FUNCTIONS
    // Core game logic and mechanics
    // ============================================

    /**
     * Initialize or reset the game to starting state
     */
    function init() {
        game.ship = new Ship(canvas.width / 2, canvas.height / 2);
        game.astervoids = [];
        game.bullets = [];
        game.score = 0;
        game.lives = CONFIG.STARTING_LIVES;
        game.wave = 0;
        game.state = 'playing';
        game.speedMultiplier = 1;
        
        // Initialize audio system
        AudioSystem.init();
        AudioSystem.resume();
        
        // Start background beat
        AudioSystem.beat.stop();
        AudioSystem.beat.start();
        
        // Start first wave
        spawnWave();
        
        updateHUD();
    }

    /**
     * Spawn a new wave of astervoids
     * Astervoids spawn away from the ship
     */
    function spawnWave() {
        game.wave++;
        
        // Calculate number of astervoids for this wave
        const asteroidCount = CONFIG.ASTEROID_BASE_COUNT + 
                              (game.wave - 1) * CONFIG.WAVE_ASTEROID_INCREMENT;
        
        // Increase speed multiplier (capped)
        game.speedMultiplier = Math.min(
            CONFIG.MAX_SPEED_MULTIPLIER,
            1 + (game.wave - 1) * (CONFIG.WAVE_SPEED_MULTIPLIER - 1)
        );
        
        // Spawn astervoids at random positions away from ship
        for (let i = 0; i < asteroidCount; i++) {
            spawnAsteroidAwayFromShip();
        }
        
        updateHUD();
    }

    /**
     * Spawn a single asteroid at a safe distance from the ship
     */
    function spawnAsteroidAwayFromShip() {
        const minDistance = 150;  // Minimum spawn distance from ship
        let x, y;
        
        // Keep trying until we find a safe spawn point
        do {
            x = Math.random() * canvas.width;
            y = Math.random() * canvas.height;
        } while (distance(x, y, game.ship.x, game.ship.y) < minDistance);
        
        // Random velocity direction
        const angle = Math.random() * Math.PI * 2;
        const speed = (CONFIG.ASTEROID_BASE_SPEED + 
                       Math.random() * CONFIG.ASTEROID_SPEED_VARIANCE) * 
                      game.speedMultiplier;
        
        game.astervoids.push(new Asteroid(
            x, y,
            CONFIG.INITIAL_ASTEROID_RADIUS,
            Math.cos(angle) * speed,
            Math.sin(angle) * speed
        ));
    }

    /**
     * Split an asteroid into two smaller pieces
     * Implements conservation of area (mass) and energy
     * @param {Asteroid} asteroid - The asteroid to split
     */
    function splitAsteroid(asteroid) {
        // Add points
        game.score += asteroid.getPoints();
        
        // Play explosion sound based on asteroid size
        const size = asteroid.radius >= 40 ? 'large' : asteroid.radius >= 25 ? 'medium' : 'small';
        AudioSystem.playExplosion(size);
        
        // Don't split if too small
        if (asteroid.radius <= CONFIG.MIN_ASTEROID_RADIUS) {
            return;  // Asteroid is destroyed, no children spawned
        }
        
        // Calculate child sizes using area conservation
        // Area ∝ r², so r1² + r2² = R² for conservation
        // We use splitRatio to determine how area is divided
        const splitRatio = randomRange(CONFIG.MIN_SPLIT_RATIO, 1 - CONFIG.MIN_SPLIT_RATIO);
        
        // Calculate child radii: r = R * sqrt(ratio)
        const radius1 = asteroid.radius * Math.sqrt(splitRatio);
        const radius2 = asteroid.radius * Math.sqrt(1 - splitRatio);
        
        // Calculate parent's kinetic energy (E = 0.5 * mass * v²)
        // Mass is proportional to area (r²), so E ∝ r² * v²
        const parentSpeed = Math.sqrt(asteroid.velocityX ** 2 + asteroid.velocityY ** 2);
        const parentEnergy = asteroid.radius ** 2 * parentSpeed ** 2;
        
        // Only spawn children that are above minimum size
        const children = [];
        
        if (radius1 >= CONFIG.MIN_ASTEROID_RADIUS) {
            children.push(radius1);
        }
        if (radius2 >= CONFIG.MIN_ASTEROID_RADIUS) {
            children.push(radius2);
        }
        
        // Calculate total mass of surviving children for energy distribution
        const totalChildMass = children.reduce((sum, r) => sum + r ** 2, 0);
        
        // Spawn child astervoids with energy conservation
        children.forEach((childRadius, index) => {
            // Perpendicular direction to original velocity (spreads children apart)
            const spreadAngle = Math.atan2(asteroid.velocityY, asteroid.velocityX) + 
                               (index === 0 ? Math.PI / 2 : -Math.PI / 2);
            
            // Energy conservation: each piece gets energy proportional to its mass
            // E_child = E_parent * (r_child² / totalChildMass)
            // Since E = m * v² and m ∝ r², we have: r² * v² = E_child
            // Therefore: v = sqrt(E_child / r²)
            const childMass = childRadius ** 2;
            const childEnergy = parentEnergy * (childMass / totalChildMass);
            const childSpeed = Math.sqrt(childEnergy / childMass);
            
            const angle = spreadAngle + randomRange(-0.5, 0.5);
            
            game.astervoids.push(new Asteroid(
                asteroid.x,
                asteroid.y,
                childRadius,
                Math.cos(angle) * childSpeed,
                Math.sin(angle) * childSpeed
            ));
        });
        
        updateHUD();
    }

    /**
     * Toggle pause state
     */
    function togglePause() {
        if (game.state === 'paused') {
            // Resume game
            game.state = game.previousState || 'playing';
            game.previousState = null;
            game.lastFrameTime = 0; // Reset to prevent delta time jump
            pauseMenu.classList.remove('visible');
            // Resume background beat
            AudioSystem.beat.start();
        } else if (game.state === 'playing' || game.state === 'waveDelay') {
            // Pause game
            game.previousState = game.state;
            game.state = 'paused';
            pauseMenu.classList.add('visible');
            // Stop ship thrust visual/sound when pausing
            if (game.ship) game.ship.thrusting = false;
            AudioSystem.thrustSound.stop();
            // Pause background beat
            AudioSystem.beat.stop();
        }
    }

    /**
     * Handle player input each frame
     */
    function handleInput() {
        if (game.state === 'gameover') {
            // Check for restart
            if (keys['Enter']) {
                init();
            }
            return;
        }

        if (game.state === 'paused') {
            // Allow restart from pause menu
            if (keys['Enter']) {
                pauseMenu.classList.remove('visible');
                init();
            }
            return;
        }
        
        if (game.state !== 'playing' && game.state !== 'waveDelay') return;
        
        // Rotation (left/right arrow or A/D or touch)
        if (keys['ArrowLeft'] || keys['KeyA'] || touch.left) {
            game.ship.angle -= CONFIG.SHIP_TURN_SPEED;
        }
        if (keys['ArrowRight'] || keys['KeyD'] || touch.right) {
            game.ship.angle += CONFIG.SHIP_TURN_SPEED;
        }
        
        // Thrust (up arrow or W or touch)
        const wasThrusting = game.ship.thrusting;
        game.ship.thrusting = keys['ArrowUp'] || keys['KeyW'] || touch.thrust;
        
        // Handle thrust sound
        if (game.ship.thrusting && !wasThrusting) {
            AudioSystem.thrustSound.start();
        } else if (!game.ship.thrusting && wasThrusting) {
            AudioSystem.thrustSound.stop();
        }
        
        // Shoot (space or touch)
        if ((keys['Space'] || touch.fire) && game.bullets.length < CONFIG.MAX_BULLETS) {
            const bullet = game.ship.shoot();
            if (bullet) {
                game.bullets.push(bullet);
            }
        }
    }

    /**
     * Check all collisions between game entities
     */
    function checkCollisions() {
        // Bullet vs Asteroid collisions
        for (let i = game.bullets.length - 1; i >= 0; i--) {
            const bullet = game.bullets[i];
            
            for (let j = game.astervoids.length - 1; j >= 0; j--) {
                const asteroid = game.astervoids[j];
                
                // Circle-to-polygon collision for bullet vs asteroid
                const bulletCircle = {
                    x: bullet.x,
                    y: bullet.y,
                    radius: CONFIG.BULLET_RADIUS
                };
                
                if (circlePolygonCollision(bulletCircle, asteroid.getWorldVertices())) {
                    // Remove bullet
                    game.bullets.splice(i, 1);
                    
                    // Remove asteroid and potentially spawn children
                    game.astervoids.splice(j, 1);
                    splitAsteroid(asteroid);
                    
                    break;  // Bullet can only hit one asteroid
                }
            }
        }
        
        // Ship vs Asteroid collisions (only if not invulnerable)
        if (game.ship.invulnerable <= 0 && game.state === 'playing') {
            const shipVertices = game.ship.getVertices();
            
            for (const asteroid of game.astervoids) {
                const asteroidVerts = asteroid.getWorldVertices();
                
                // Check if any ship vertex is inside asteroid
                for (const vertex of shipVertices) {
                    if (pointInPolygon(vertex, asteroidVerts)) {
                        handleShipHit();
                        return;
                    }
                }
                
                // Check if any asteroid vertex is inside ship triangle
                for (const vertex of asteroidVerts) {
                    if (pointInPolygon(vertex, shipVertices)) {
                        handleShipHit();
                        return;
                    }
                }
            }
        }
    }

    /**
     * Handle ship being hit by asteroid
     */
    function handleShipHit() {
        game.lives--;
        updateHUD();
        
        // Play ship explosion sound
        AudioSystem.playShipExplosion();
        
        // Stop thrust sound if playing
        AudioSystem.thrustSound.stop();
        
        if (game.lives <= 0) {
            game.state = 'gameover';
            // Stop background beat on game over
            AudioSystem.beat.stop();
        } else {
            // Respawn ship at center with invulnerability
            game.ship.reset(canvas);
        }
    }

    /**
     * Update HUD display elements
     */
    function updateHUD() {
        scoreDisplay.textContent = `Score: ${game.score}`;
        waveDisplay.textContent = `Wave: ${game.wave}`;
        livesDisplay.textContent = `Lives: ${game.lives}`;
    }

    /**
     * Draw centered text message on screen
     * @param {string} text - Message to display
     * @param {number} y - Y position
     * @param {number} size - Font size
     */
    function drawCenteredText(text, y, size = 32) {
        ctx.fillStyle = CONFIG.STROKE_COLOR;
        ctx.font = `${size}px 'Courier New', monospace`;
        ctx.textAlign = 'center';
        ctx.fillText(text, canvas.width / 2, y);
    }

    // ============================================
    // SECTION 6: GAME LOOP
    // Main update and render cycle
    // ============================================

    /**
     * Main game loop - called every frame
     * @param {number} timestamp - Current time from requestAnimationFrame
     */
    function gameLoop(timestamp) {
        // Calculate delta time (normalized to 60fps: dt=1.0 at 60fps, dt=0.5 at 120fps)
        if (!game.lastFrameTime) game.lastFrameTime = timestamp;
        const elapsed = timestamp - game.lastFrameTime;
        game.lastFrameTime = timestamp;
        
        // Calculate delta time multiplier (1.0 = one frame at 60fps = 16.67ms)
        const targetFrameTime = 1000 / CONFIG.TARGET_FPS;
        const dt = Math.min(elapsed / targetFrameTime, 3); // Cap at 3x to prevent huge jumps
        
        // --- UPDATE PHASE ---
        
        // Handle player input
        handleInput();
        
        // Update game state based on current state (skip when paused)
        if ((game.state === 'playing' || game.state === 'waveDelay') && game.state !== 'paused') {
            // Update ship
            game.ship.update(canvas, dt);
            
            // Update astervoids
            game.astervoids.forEach(asteroid => asteroid.update(canvas, dt));
            
            // Update bullets and remove expired ones
            game.bullets = game.bullets.filter(bullet => {
                bullet.update(canvas, dt);
                return !bullet.isExpired();
            });
            
            // Check collisions
            checkCollisions();
            
            // Check for wave completion
            if (game.astervoids.length === 0 && game.state === 'playing') {
                game.state = 'waveDelay';
                game.waveDelayTimer = CONFIG.WAVE_DELAY;
            }
            
            // Handle wave delay countdown (adjusted for delta time)
            if (game.state === 'waveDelay') {
                game.waveDelayTimer -= dt;
                if (game.waveDelayTimer <= 0) {
                    spawnWave();
                    game.state = 'playing';
                    AudioSystem.playNewWave();
                }
            }
            
            // Update background beat tempo based on asteroid count
            const maxAstervoids = CONFIG.ASTEROID_BASE_COUNT + (game.wave - 1) * CONFIG.WAVE_ASTEROID_INCREMENT;
            const totalAsteroidArea = game.astervoids.reduce((sum, a) => sum + a.radius * a.radius, 0);
            const maxArea = maxAstervoids * CONFIG.INITIAL_ASTEROID_RADIUS * CONFIG.INITIAL_ASTEROID_RADIUS;
            AudioSystem.beat.updateTempo(totalAsteroidArea, maxArea);
        }
        
        // --- RENDER PHASE ---
        
        // Clear canvas
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw game entities
        game.astervoids.forEach(asteroid => asteroid.draw(ctx));
        game.bullets.forEach(bullet => bullet.draw(ctx));
        game.ship.draw(ctx);
        
        // Draw state-specific overlays
        if (game.state === 'waveDelay') {
            drawCenteredText(`WAVE ${game.wave + 1}`, canvas.height / 2, 48);
        }
        
        if (game.state === 'gameover') {
            drawCenteredText('GAME OVER', canvas.height / 2 - 40, 48);
            drawCenteredText(`Final Score: ${game.score}`, canvas.height / 2 + 10, 24);
            drawCenteredText('Press ENTER to restart', canvas.height / 2 + 50, 20);
        }
        
        // Request next frame
        requestAnimationFrame(gameLoop);
    }

    // ============================================
    // SECTION 7: EVENT LISTENERS & INITIALIZATION
    // Set up input handling and start the game
    // ============================================

    // Track key presses
    document.addEventListener('keydown', (e) => {
        keys[e.code] = true;
        
        // Initialize and resume audio on first user interaction
        AudioSystem.init();
        AudioSystem.resume();
        
        // Prevent default for game keys (stops page scrolling)
        if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
            e.preventDefault();
        }

        // Toggle pause with Escape or P (only handle once per press)
        if ((e.code === 'Escape' || e.code === 'KeyP') && game.state !== 'gameover') {
            togglePause();
            e.preventDefault();
        }
    });

    document.addEventListener('keyup', (e) => {
        keys[e.code] = false;
    });

    // Prevent focus loss from affecting input - auto pause
    window.addEventListener('blur', () => {
        // Clear all keys when window loses focus
        Object.keys(keys).forEach(key => keys[key] = false);
        if (game.ship) game.ship.thrusting = false;
        AudioSystem.thrustSound.stop();
        
        // Auto-pause when window loses focus (only on desktop)
        if (!isTouchDevice && (game.state === 'playing' || game.state === 'waveDelay')) {
            togglePause();
        }
    });

    // ============================================
    // SECTION 8: MOBILE TOUCH CONTROLS
    // Touch input handling for mobile devices
    // ============================================

    // Detect touch device
    const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
    
    if (isTouchDevice) {
        document.getElementById('game-container').classList.add('touch-enabled');
    }

    // Touch control elements
    const touchButtons = {
        left: document.getElementById('touch-left'),
        right: document.getElementById('touch-right'),
        thrust: document.getElementById('touch-thrust'),
        fire: document.getElementById('touch-fire'),
        pause: document.getElementById('touch-pause'),
        restart: document.getElementById('touch-restart')
    };

    // Helper to set touch state
    function setTouchState(control, active) {
        touch[control] = active;
        if (touchButtons[control]) {
            touchButtons[control].classList.toggle('active', active);
        }
    }

    // Setup touch button handlers
    function setupTouchButton(element, control) {
        if (!element) return;

        element.addEventListener('touchstart', (e) => {
            e.preventDefault();
            // Initialize and resume audio on first touch
            AudioSystem.init();
            AudioSystem.resume();
            setTouchState(control, true);
        }, { passive: false });

        element.addEventListener('touchend', (e) => {
            e.preventDefault();
            setTouchState(control, false);
        }, { passive: false });

        element.addEventListener('touchcancel', (e) => {
            setTouchState(control, false);
        });
    }

    // Initialize touch controls
    setupTouchButton(touchButtons.left, 'left');
    setupTouchButton(touchButtons.right, 'right');
    setupTouchButton(touchButtons.thrust, 'thrust');
    setupTouchButton(touchButtons.fire, 'fire');

    // Pause button handler
    if (touchButtons.pause) {
        touchButtons.pause.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (game.state !== 'gameover') {
                togglePause();
            }
        }, { passive: false });
    }

    // Restart button handler
    if (touchButtons.restart) {
        touchButtons.restart.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (game.state === 'gameover' || game.state === 'paused') {
                pauseMenu.classList.remove('visible');
                touchButtons.restart.classList.remove('visible');
                init();
            }
        }, { passive: false });
    }

    // Show/hide restart button based on game state
    const originalGameLoop = gameLoop;
    function gameLoopWithMobileUI() {
        // Update restart button visibility
        if (touchButtons.restart) {
            if (game.state === 'gameover') {
                touchButtons.restart.classList.add('visible');
            } else {
                touchButtons.restart.classList.remove('visible');
            }
        }
        originalGameLoop();
    }

    // Prevent default touch behaviors on game container (no zooming/scrolling)
    document.getElementById('game-container').addEventListener('touchstart', (e) => {
        if (e.target.classList.contains('touch-btn')) return;
        e.preventDefault();
    }, { passive: false });

    document.getElementById('game-container').addEventListener('touchmove', (e) => {
        e.preventDefault();
    }, { passive: false });

    // ============================================
    // SECTION 9: WINDOW RESIZE HANDLING
    // Dynamic canvas sizing for responsive gameplay
    // ============================================

    // Handle window resize events
    window.addEventListener('resize', () => {
        resizeCanvas();
    });

    // Handle orientation change on mobile devices
    window.addEventListener('orientationchange', () => {
        // Small delay to let the browser finish orientation change
        setTimeout(() => {
            resizeCanvas();
        }, 100);
    });

    // Handle screen resize via visualViewport API (better for mobile keyboards, etc.)
    if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', () => {
            resizeCanvas();
        });
    }

    // Initial canvas sizing before game starts
    resizeCanvas();

    // Start the game when page loads
    init();
    if (isTouchDevice) {
        // Use wrapper that updates mobile UI
        requestAnimationFrame(function mobileLoop() {
            if (touchButtons.restart) {
                touchButtons.restart.classList.toggle('visible', game.state === 'gameover');
            }
            requestAnimationFrame(mobileLoop);
        });
    }
    requestAnimationFrame(gameLoop);  // Use rAF to provide timestamp

    </script>
</body>
</html>
