<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <!-- iOS standalone mode (Add to Home Screen) -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Astervoids">
    <!-- Android theme -->
    <meta name="theme-color" content="#000000">
    <meta name="mobile-web-app-capable" content="yes">
    <!-- Web App Manifest for Add to Home Screen -->
    <link rel="manifest" href="manifest.json">
    <title>Astervoids</title>
    <style>
        /* ============================================
           STYLES - Minimal CSS for game presentation
           ============================================ */
        
        /* Reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Dark background to match classic arcade feel */
        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile */
            font-family: 'Courier New', monospace;
            overflow: hidden;
            touch-action: none; /* Prevent browser gestures */
        }

        /* Game container for canvas and HUD positioning */
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile */
            max-width: 100%;
            max-height: 100%;
        }

        /* Canvas with subtle border - fills container */
        #game {
            display: block;
            width: 100%;
            height: 100%;
            border: none;
        }

        /* HUD overlay for score, lives, and wave info */
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            color: #fff;
            font-size: 18px;
            pointer-events: none;
        }

        /* Instructions shown at bottom */
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 0;
            right: 0;
            text-align: center;
            color: #666;
            font-size: 12px;
            pointer-events: none;
        }

        /* Pause menu overlay */
        #pause-menu {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
        }

        #pause-menu.visible {
            display: flex;
        }

        #pause-menu h1 {
            font-size: 48px;
            margin-bottom: 30px;
            letter-spacing: 4px;
        }

        #pause-menu .menu-item {
            font-size: 20px;
            margin: 10px 0;
            color: #888;
        }

        #pause-menu .menu-item span {
            color: #fff;
        }

        /* Hide keyboard instructions on touch devices */
        .touch-enabled #pause-menu .desktop-only {
            display: none;
        }

        #pause-menu .touch-only {
            display: none;
        }

        .touch-enabled #pause-menu .touch-only {
            display: block;
        }

        /* Pause menu restart button for touch */
        #pause-restart-btn {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.6);
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 20px;
            padding: 12px 30px;
            border-radius: 8px;
            margin-top: 10px;
            cursor: pointer;
            touch-action: manipulation;
        }

        #pause-restart-btn:active {
            background: rgba(255, 255, 255, 0.35);
        }

        /* Start screen overlay */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            z-index: 100;
        }

        #start-screen.hidden {
            display: none;
        }

        #start-screen h1 {
            font-size: 51px;
            margin-bottom: 40px;
            letter-spacing: 8px;
        }

        #start-screen .start-prompt {
            font-size: 24px;
            color: #888;
            animation: pulse 1.5s ease-in-out infinite;
        }

        #start-screen .start-prompt span {
            color: #fff;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        /* Session picker styles */
        #session-picker {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 400px;
            padding: 0 20px;
        }

        #session-picker .picker-status {
            font-size: 14px;
            color: #888;
            margin-bottom: 15px;
            min-height: 20px;
        }

        #session-picker .picker-status.error {
            color: #ff4444;
        }

        #session-picker .picker-status.connecting {
            color: #ffff00;
        }

        #session-list {
            width: 100%;
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 20px;
            border: 1px solid #444;
            border-radius: 4px;
        }

        #session-list:empty::after {
            content: 'No sessions available';
            display: block;
            padding: 20px;
            text-align: center;
            color: #666;
        }

        .session-item {
            padding: 12px 15px;
            border-bottom: 1px solid #333;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.15s;
        }

        .session-item:last-child {
            border-bottom: none;
        }

        .session-item:hover:not(.disabled) {
            background: rgba(255, 255, 255, 0.1);
        }

        .session-item.selected {
            background: rgba(255, 255, 255, 0.2);
            border-left: 3px solid #fff;
        }

        .session-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .session-item .session-name {
            font-size: 16px;
        }

        .session-item .session-players {
            font-size: 12px;
            color: #888;
        }

        .session-item.disabled .session-players {
            color: #ff4444;
        }

        #picker-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
        }

        .picker-btn {
            background: transparent;
            border: 2px solid #fff;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            padding: 12px 24px;
            cursor: pointer;
            transition: all 0.15s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .picker-btn:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.2);
        }

        .picker-btn:active:not(:disabled) {
            background: rgba(255, 255, 255, 0.3);
        }

        .picker-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            border-color: #666;
            color: #666;
        }

        .picker-btn.primary {
            background: rgba(255, 255, 255, 0.15);
        }

        .picker-btn.solo {
            border-color: #888;
            color: #888;
            font-size: 14px;
            margin-top: 10px;
        }

        .picker-btn.solo:hover:not(:disabled) {
            border-color: #fff;
            color: #fff;
        }

        /* Mobile touch controls */
        #mobile-controls {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .touch-enabled #mobile-controls {
            display: block;
        }

        .touch-enabled #instructions {
            display: none;
        }

        .touch-btn {
            position: absolute;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.4);
            color: rgba(255, 255, 255, 0.7);
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        .touch-btn:active, .touch-btn.active {
            background: rgba(255, 255, 255, 0.35);
            border-color: rgba(255, 255, 255, 0.8);
        }

        /* Left side - movement controls */
        #touch-left {
            width: 70px;
            height: 70px;
            bottom: 100px;
            left: 20px;
        }

        #touch-right {
            width: 70px;
            height: 70px;
            bottom: 100px;
            left: 110px;
        }

        #touch-thrust {
            width: 80px;
            height: 80px;
            bottom: 20px;
            left: 60px;
        }

        /* Right side - action controls */
        #touch-fire {
            width: 90px;
            height: 90px;
            bottom: 40px;
            right: 30px;
        }

        #touch-pause {
            width: 50px;
            height: 50px;
            top: 50px;
            right: 10px;
            font-size: 18px;
        }

        /* Restart button for game over on mobile */
        #touch-restart {
            width: 120px;
            height: 50px;
            border-radius: 25px;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            display: none;
        }

        .touch-enabled #touch-restart.visible {
            display: flex;
        }

        /* Fullscreen button - only visible on touch devices */
        #touch-fullscreen {
            width: 50px;
            height: 50px;
            top: 50px;
            left: 10px;
            font-size: 20px;
        }

        /* Hide fullscreen button when already in fullscreen or standalone mode */
        .fullscreen-active #touch-fullscreen,
        .standalone-mode #touch-fullscreen {
            display: none;
        }
    </style>
</head>
<body>
    <!-- Game Container: holds canvas and overlay elements -->
    <div id="game-container">
        <canvas id="game" width="800" height="600"></canvas>
        
        <!-- HUD: displays game stats -->
        <div id="hud">
            <span id="score">Score: 0</span>
            <span id="session-indicator"></span>
            <span id="wave">Wave: 1</span>
            <span id="lives">Lives: 3</span>
        </div>
        
        <!-- Instructions: control hints -->
        <div id="instructions">
            Arrow Keys or WASD to move | SPACE to shoot | ESC to pause
        </div>

        <!-- Pause menu overlay -->
        <div id="pause-menu">
            <h1>PAUSED</h1>
            <div class="menu-item desktop-only"><span>ESC</span> or <span>P</span> - Resume</div>
            <div class="menu-item desktop-only"><span>ENTER</span> - Restart Game</div>
            <div class="menu-item desktop-only"><span>Arrow Keys</span> / <span>WASD</span> - Move</div>
            <div class="menu-item desktop-only"><span>SPACE</span> - Shoot</div>
            <div class="menu-item touch-only">Tap <span>❚❚</span> to Resume</div>
            <div class="menu-item touch-only"><button id="pause-restart-btn">RESTART</button></div>
        </div>

        <!-- Start screen overlay -->
        <div id="start-screen">
            <h1>ASTERVOIDS</h1>
            <div id="session-picker">
                <div id="picker-status" class="picker-status connecting">Connecting...</div>
                <div id="session-list"></div>
                <div id="picker-buttons">
                    <button id="btn-join" class="picker-btn primary" disabled>Join Session</button>
                    <button id="btn-create" class="picker-btn" disabled>Create Session</button>
                    <button id="btn-solo" class="picker-btn solo">Solo Play</button>
                </div>
            </div>
        </div>

        <!-- Mobile touch controls -->
        <div id="mobile-controls">
            <div id="touch-left" class="touch-btn">◀</div>
            <div id="touch-right" class="touch-btn">▶</div>
            <div id="touch-thrust" class="touch-btn">▲</div>
            <div id="touch-fire" class="touch-btn">FIRE</div>
            <div id="touch-pause" class="touch-btn">❚❚</div>
            <div id="touch-restart" class="touch-btn">RESTART</div>
            <div id="touch-fullscreen" class="touch-btn">⛶</div>
        </div>
    </div>

    <!-- SignalR for session connectivity -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/8.0.0/signalr.min.js"></script>
    <!-- Session client module -->
    <script src="/js/session-client.js"></script>

    <script>
    /* ================================================================
       ASTERVOIDS GAME
       A single-file HTML5 Canvas implementation following best practices
       ================================================================ */

    // ============================================
    // SECTION 0: AUDIO SYSTEM
    // Web Audio API sound generation for classic arcade sounds
    // ============================================
    
    const AudioSystem = {
        ctx: null,
        enabled: true,
        masterVolume: 0.3,
        
        // Initialize the audio context (must be called after user interaction)
        init() {
            if (this.ctx) return;
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        },
        
        // Resume audio context if suspended (browser autoplay policy)
        resume() {
            if (this.ctx && this.ctx.state === 'suspended') {
                this.ctx.resume();
            }
        },
        
        // Create a gain node with specified volume
        createGain(volume = 1) {
            const gain = this.ctx.createGain();
            gain.gain.value = volume * this.masterVolume;
            gain.connect(this.ctx.destination);
            return gain;
        },
        
        // Create a white noise buffer of specified duration
        createNoiseBuffer(duration) {
            const bufferSize = this.ctx.sampleRate * duration;
            const noiseBuffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            return noiseBuffer;
        },
        
        // Safely stop an audio node
        stopNode(node) {
            if (node) {
                try { node.stop(); } catch (e) {}
            }
            return null;
        },
        
        // Ship thrust sound - continuous low rumble
        thrustSound: {
            noiseNode: null,
            gainNode: null,
            
            start() {
                if (!AudioSystem.ctx || !AudioSystem.enabled) return;
                if (this.noiseNode) return; // Already playing
                
                const ctx = AudioSystem.ctx;
                
                // Noise source
                this.noiseNode = ctx.createBufferSource();
                this.noiseNode.buffer = AudioSystem.createNoiseBuffer(0.5);
                this.noiseNode.loop = true;
                
                // Low-pass filter for rumble
                const filter = ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 150;
                
                // Gain for volume control
                this.gainNode = ctx.createGain();
                this.gainNode.gain.value = 0.15 * AudioSystem.masterVolume;
                
                // Connect nodes
                this.noiseNode.connect(filter);
                filter.connect(this.gainNode);
                this.gainNode.connect(ctx.destination);
                
                this.noiseNode.start();
            },
            
            stop() {
                this.noiseNode = AudioSystem.stopNode(this.noiseNode);
                this.gainNode = null;
            }
        },
        
        // Ship fire sound - classic pew
        playFire() {
            if (!this.ctx || !this.enabled) return;
            
            const ctx = this.ctx;
            const now = ctx.currentTime;
            
            // Main tone
            const osc = ctx.createOscillator();
            osc.type = 'square';
            osc.frequency.setValueAtTime(880, now);
            osc.frequency.exponentialRampToValueAtTime(110, now + 0.1);
            
            const gain = this.createGain(0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
            
            osc.connect(gain);
            osc.start(now);
            osc.stop(now + 0.1);
        },
        
        // Asteroid explosion - different pitch based on size
        playExplosion(size = 'large') {
            if (!this.ctx || !this.enabled) return;
            
            const ctx = this.ctx;
            const now = ctx.currentTime;
            
            // Frequency based on asteroid size (smaller = higher pitch)
            const baseFreq = size === 'large' ? 60 : size === 'medium' ? 90 : 120;
            const duration = size === 'large' ? 0.4 : size === 'medium' ? 0.3 : 0.2;
            
            // Noise burst for explosion
            const noise = ctx.createBufferSource();
            noise.buffer = this.createNoiseBuffer(duration);
            
            // Band-pass filter
            const filter = ctx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.value = baseFreq * 3;
            filter.Q.value = 1;
            
            const gain = this.createGain(0.25);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            noise.connect(filter);
            filter.connect(gain);
            noise.start(now);
            noise.stop(now + duration);
            
            // Add a low thump
            const osc = ctx.createOscillator();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(baseFreq, now);
            osc.frequency.exponentialRampToValueAtTime(20, now + duration * 0.5);
            
            const oscGain = this.createGain(0.3);
            oscGain.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.5);
            
            osc.connect(oscGain);
            osc.start(now);
            osc.stop(now + duration * 0.5);
        },
        
        // Ship explosion - dramatic death sound
        playShipExplosion() {
            if (!this.ctx || !this.enabled) return;
            
            const ctx = this.ctx;
            const now = ctx.currentTime;
            
            // Multiple descending tones
            for (let i = 0; i < 3; i++) {
                const osc = ctx.createOscillator();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(400 - i * 100, now + i * 0.05);
                osc.frequency.exponentialRampToValueAtTime(30, now + 0.8);
                
                const gain = this.createGain(0.2);
                gain.gain.setValueAtTime(0.2 * this.masterVolume, now + i * 0.05);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
                
                osc.connect(gain);
                osc.start(now + i * 0.05);
                osc.stop(now + 0.8);
            }
            
            // Noise burst
            const noise = ctx.createBufferSource();
            noise.buffer = this.createNoiseBuffer(0.6);
            
            const filter = ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(2000, now);
            filter.frequency.exponentialRampToValueAtTime(100, now + 0.6);
            
            const noiseGain = this.createGain(0.3);
            noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
            
            noise.connect(filter);
            filter.connect(noiseGain);
            noise.start(now);
            noise.stop(now + 0.6);
        },
        
        // Extra life sound
        playExtraLife() {
            if (!this.ctx || !this.enabled) return;
            
            const ctx = this.ctx;
            const now = ctx.currentTime;
            
            const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
            
            notes.forEach((freq, i) => {
                const osc = ctx.createOscillator();
                osc.type = 'square';
                osc.frequency.value = freq;
                
                const gain = this.createGain(0.1);
                gain.gain.setValueAtTime(0, now + i * 0.1);
                gain.gain.linearRampToValueAtTime(0.1 * this.masterVolume, now + i * 0.1 + 0.02);
                gain.gain.linearRampToValueAtTime(0, now + i * 0.1 + 0.15);
                
                osc.connect(gain);
                osc.start(now + i * 0.1);
                osc.stop(now + i * 0.1 + 0.15);
            });
        },
        
        // Classic Astervoids background beat - two alternating tones
        beat: {
            intervalId: null,
            beatIndex: 0,
            tempo: 1000, // ms between beats
            minTempo: 150,
            maxTempo: 1000,
            
            start() {
                if (this.intervalId) return;
                this.beatIndex = 0;
                this.tempo = this.maxTempo;
                this.scheduleBeat();
            },
            
            stop() {
                if (this.intervalId) {
                    clearTimeout(this.intervalId);
                    this.intervalId = null;
                }
            },
            
            scheduleBeat() {
                this.intervalId = setTimeout(() => {
                    this.playBeat();
                    this.scheduleBeat();
                }, this.tempo);
            },
            
            playBeat() {
                if (!AudioSystem.ctx || !AudioSystem.enabled) return;
                
                const ctx = AudioSystem.ctx;
                const now = ctx.currentTime;
                
                // Alternating low tones (like original Astervoids)
                const freq = this.beatIndex % 2 === 0 ? 55 : 50; // A1 and ~G#1
                
                const osc = ctx.createOscillator();
                osc.type = 'triangle';
                osc.frequency.value = freq;
                
                const gain = AudioSystem.createGain(0.25);
                gain.gain.setValueAtTime(0.25 * AudioSystem.masterVolume, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                
                osc.connect(gain);
                osc.start(now);
                osc.stop(now + 0.15);
                
                this.beatIndex++;
            },
            
            // Adjust tempo based on number of astervoids (fewer = faster)
            updateTempo(asteroidCount, maxAstervoids) {
                if (maxAstervoids <= 0) maxAstervoids = 1;
                const ratio = asteroidCount / maxAstervoids;
                this.tempo = this.minTempo + (this.maxTempo - this.minTempo) * ratio;
            }
        },
        
        // Saucer sound (for future use)
        saucerSound: {
            oscillator: null,
            gainNode: null,
            
            start(isSmall = false) {
                if (!AudioSystem.ctx || !AudioSystem.enabled) return;
                if (this.oscillator) return;
                
                const ctx = AudioSystem.ctx;
                
                this.oscillator = ctx.createOscillator();
                this.oscillator.type = 'sawtooth';
                this.oscillator.frequency.value = isSmall ? 1200 : 800;
                
                // LFO for warble effect
                const lfo = ctx.createOscillator();
                lfo.frequency.value = isSmall ? 8 : 5;
                
                const lfoGain = ctx.createGain();
                lfoGain.gain.value = isSmall ? 100 : 60;
                
                lfo.connect(lfoGain);
                lfoGain.connect(this.oscillator.frequency);
                
                this.gainNode = AudioSystem.createGain(0.08);
                
                this.oscillator.connect(this.gainNode);
                
                this.oscillator.start();
                lfo.start();
            },
            
            stop() {
                this.oscillator = AudioSystem.stopNode(this.oscillator);
                this.gainNode = null;
            }
        },
        
        // New wave sound
        playNewWave() {
            if (!this.ctx || !this.enabled) return;
            
            const ctx = this.ctx;
            const now = ctx.currentTime;
            
            // Ascending tone
            const osc = ctx.createOscillator();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.exponentialRampToValueAtTime(600, now + 0.3);
            
            const gain = this.createGain(0.15);
            gain.gain.setValueAtTime(0.15 * this.masterVolume, now);
            gain.gain.linearRampToValueAtTime(0.15 * this.masterVolume, now + 0.2);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
            
            osc.connect(gain);
            osc.start(now);
            osc.stop(now + 0.4);
        }
    };

    // ============================================
    // SECTION 1: CONFIGURATION
    // All tunable game parameters in one place
    // All positions are normalized (0-1), sizes relative to shorter dimension
    // ============================================
    const CONFIG = {
        // Timing settings
        TARGET_FPS: 60,             // Target frame rate for physics
        
        // Ship settings (normalized: sizes relative to shorter dimension)
        SHIP_SIZE: 0.025,           // Ship triangle size (normalized)
        SHIP_THRUST: 0.009,         // Acceleration per frame (normalized, ~0.15/600*60)
        SHIP_FRICTION: 0.99,        // Velocity decay (1 = no friction)
        SHIP_TURN_SPEED: 0.08,      // Rotation speed in radians per frame
        SHIP_MAX_SPEED: 0.8,        // Maximum velocity per second (normalized)
        
        // Bullet settings (normalized)
        BULLET_SPEED: 1.0,          // Bullet speed per second (normalized)
        BULLET_LIFETIME: 60,        // Frames before bullet expires
        BULLET_RADIUS: 0.0033,      // Bullet size (normalized)
        MAX_BULLETS: 10,            // Maximum bullets on screen
        SHOOT_COOLDOWN: 10,         // Frames between shots
        
        // Asteroid settings (normalized)
        ASTEROID_BASE_COUNT: 1,     // Starting astervoids in wave 1
        ASTEROID_BASE_SPEED: 0.15,  // Base asteroid speed per second (normalized)
        ASTEROID_SPEED_VARIANCE: 0.1, // Random speed variation (normalized)
        ASTEROID_VERTICES: 10,      // Number of vertices per asteroid
        ASTEROID_JAGGEDNESS: 0.4,   // Shape irregularity (0-1)
        MIN_ASTEROID_RADIUS: 0.025, // Min radius before no split (normalized)
        INITIAL_ASTEROID_RADIUS: 0.083, // Starting asteroid size (normalized)
        
        // Asteroid splitting
        SPLIT_COUNT: 2,             // Always split into 2 pieces
        MIN_SPLIT_RATIO: 0.1,       // Smallest piece is at least 10% of original
        
        // Scoring (points awarded based on asteroid size - thresholds normalized)
        POINTS_LARGE: 20,           // Points for large astervoids
        POINTS_MEDIUM: 50,          // Points for medium astervoids
        POINTS_SMALL: 100,          // Points for small astervoids
        ASTEROID_LARGE_THRESHOLD: 0.067,  // ~40px at 600 ref
        ASTEROID_MEDIUM_THRESHOLD: 0.042, // ~25px at 600 ref
        
        // Game settings
        STARTING_LIVES: 3,          // Lives at game start
        INVULNERABILITY_TIME: 180,  // Frames of invulnerability after respawn
        WAVE_DELAY: 120,            // Frames to wait between waves
        
        // Wave progression
        WAVE_ASTEROID_INCREMENT: 1, // Extra astervoids per wave
        WAVE_SPEED_MULTIPLIER: 1.1, // Speed increase per wave
        MAX_SPEED_MULTIPLIER: 2.0,  // Cap on speed scaling
        
        // Visual settings
        STROKE_COLOR: '#fff',       // Primary drawing color
        THRUST_COLOR: '#f80',       // Thrust flame color
        INVULN_BLINK_RATE: 10,      // Blink frequency when invulnerable
        
        // Start screen
        START_SCREEN_ASTERVOIDS: 4,  // Astervoids shown on start screen
        SPAWN_MIN_DISTANCE: 0.25    // Minimum spawn distance from ship (normalized)
    };

    // ============================================
    // SECTION 2: UTILITY FUNCTIONS
    // Helper functions used throughout the game
    // ============================================

    /**
     * Get the reference dimension for size normalization (shorter of width/height)
     * This ensures circles remain circular regardless of aspect ratio
     * @returns {number} Reference dimension in pixels
     */
    function getReferenceDimension() {
        return Math.min(getGameWidth(), getGameHeight());
    }

    /**
     * Convert normalized X position (0-1) to pixel X within gameplay area
     * @param {number} normX - Normalized X (0 = left, 1 = right)
     * @returns {number} Pixel X coordinate
     */
    function fromNormalizedX(normX) {
        return normX * getGameWidth();
    }

    /**
     * Convert pixel X to normalized X position (0-1)
     * @param {number} pixelX - Pixel X coordinate
     * @returns {number} Normalized X (0-1)
     */
    function toNormalizedX(pixelX) {
        return pixelX / getGameWidth();
    }

    /**
     * Convert normalized Y position (0-1) to pixel Y within gameplay area
     * @param {number} normY - Normalized Y (0 = top, 1 = bottom)
     * @returns {number} Pixel Y coordinate
     */
    function fromNormalizedY(normY) {
        return normY * getGameHeight();
    }

    /**
     * Convert pixel Y to normalized Y position (0-1)
     * @param {number} pixelY - Pixel Y coordinate
     * @returns {number} Normalized Y (0-1)
     */
    function toNormalizedY(pixelY) {
        return pixelY / getGameHeight();
    }

    /**
     * Convert normalized size to pixel size
     * Uses shorter dimension as reference to preserve aspect ratio of shapes
     * @param {number} normSize - Normalized size (fraction of reference dimension)
     * @returns {number} Pixel size
     */
    function fromNormalizedSize(normSize) {
        return normSize * getReferenceDimension();
    }

    /**
     * Convert pixel size to normalized size
     * @param {number} pixelSize - Pixel size
     * @returns {number} Normalized size
     */
    function toNormalizedSize(pixelSize) {
        return pixelSize / getReferenceDimension();
    }

    /**
     * Convert normalized velocity to pixel velocity for X axis
     * Velocity is stored as "fraction of dimension per second"
     * @param {number} normVelX - Normalized velocity (per second)
     * @returns {number} Pixel velocity per frame (at 60fps)
     */
    function fromNormalizedVelocityX(normVelX) {
        return normVelX * getGameWidth() / CONFIG.TARGET_FPS;
    }

    /**
     * Convert normalized velocity to pixel velocity for Y axis
     * @param {number} normVelY - Normalized velocity (per second)
     * @returns {number} Pixel velocity per frame (at 60fps)
     */
    function fromNormalizedVelocityY(normVelY) {
        return normVelY * getGameHeight() / CONFIG.TARGET_FPS;
    }

    /**
     * Convert normalized velocity (reference-dimension per second) to position delta for X axis
     * This accounts for aspect ratio to ensure consistent visual speed in all directions
     * @param {number} normVel - Normalized velocity (reference dimension per second)
     * @returns {number} Position delta in normalized X coordinates (per frame at 60fps)
     */
    function velocityToNormalizedDeltaX(normVel) {
        const refDim = getReferenceDimension();
        return normVel * refDim / getGameWidth() / CONFIG.TARGET_FPS;
    }

    /**
     * Convert normalized velocity (reference-dimension per second) to position delta for Y axis
     * This accounts for aspect ratio to ensure consistent visual speed in all directions
     * @param {number} normVel - Normalized velocity (reference dimension per second)
     * @returns {number} Position delta in normalized Y coordinates (per frame at 60fps)
     */
    function velocityToNormalizedDeltaY(normVel) {
        const refDim = getReferenceDimension();
        return normVel * refDim / getGameHeight() / CONFIG.TARGET_FPS;
    }

    /**
     * Convert a normalized size to normalized X coordinate offset
     * Used when adding size-based offsets to positions (e.g., nose position relative to ship center)
     * @param {number} normSize - Size normalized to reference dimension
     * @returns {number} Equivalent offset in normalized X coordinates
     */
    function sizeToNormalizedX(normSize) {
        const refDim = getReferenceDimension();
        return normSize * refDim / getGameWidth();
    }

    /**
     * Convert a normalized size to normalized Y coordinate offset
     * @param {number} normSize - Size normalized to reference dimension
     * @returns {number} Equivalent offset in normalized Y coordinates
     */
    function sizeToNormalizedY(normSize) {
        const refDim = getReferenceDimension();
        return normSize * refDim / getGameHeight();
    }

    /**
     * Resize the canvas to fill the window while maintaining game state
     * With normalized coordinates, positions don't need scaling on resize
     */
    function resizeCanvas(forceViewportRecalc = false) {
        const container = document.getElementById('game-container');
        const newWidth = container.clientWidth;
        const newHeight = container.clientHeight;
        
        // Only resize if dimensions changed, unless forcing viewport recalculation
        const dimensionsChanged = newWidth !== canvas.width || newHeight !== canvas.height;
        if (!dimensionsChanged && !forceViewportRecalc) return;
        
        // Update canvas dimensions to fill container
        canvas.width = newWidth;
        canvas.height = newHeight;
        
        // Calculate viewport (gameplay area) based on mode
        if (isSessionMode() && game.sessionInfo && game.sessionInfo.aspectRatio) {
            // Session mode: constrain to locked aspect ratio
            const lockedAspectRatio = game.sessionInfo.aspectRatio;
            const windowAspectRatio = newWidth / newHeight;
            
            let viewportWidth, viewportHeight;
            if (windowAspectRatio > lockedAspectRatio) {
                // Window is wider than locked ratio - pillarbox (black bars on sides)
                viewportHeight = newHeight;
                viewportWidth = newHeight * lockedAspectRatio;
            } else {
                // Window is taller than locked ratio - letterbox (black bars top/bottom)
                viewportWidth = newWidth;
                viewportHeight = newWidth / lockedAspectRatio;
            }
            
            game.viewport.width = viewportWidth;
            game.viewport.height = viewportHeight;
            game.viewport.x = (newWidth - viewportWidth) / 2;
            game.viewport.y = (newHeight - viewportHeight) / 2;
        } else {
            // Solo mode: gameplay area is the entire canvas
            game.viewport.x = 0;
            game.viewport.y = 0;
            game.viewport.width = newWidth;
            game.viewport.height = newHeight;
        }
        
        // No need to scale entity positions - they use normalized coordinates (0-1)
        // The conversion functions (fromNormalizedX, etc.) handle the mapping to pixels
    }

    /**
     * Get the gameplay area width (viewport width in session mode, canvas width in solo)
     * @returns {number} Gameplay width in pixels
     */
    function getGameWidth() {
        return game.viewport.width || canvas.width;
    }

    /**
     * Get the gameplay area height (viewport height in session mode, canvas height in solo)
     * @returns {number} Gameplay height in pixels
     */
    function getGameHeight() {
        return game.viewport.height || canvas.height;
    }

    /**
     * Wraps a normalized position (0-1) to stay within bounds
     * Creates the classic "wrap-around" effect
     * @param {number} value - Current normalized position (0-1)
     * @returns {number} Wrapped normalized position (0-1)
     */
    function wrapNormalized(value) {
        if (value < 0) return 1 + value;
        if (value > 1) return value - 1;
        return value;
    }

    /**
     * Calculates distance between two normalized points
     * @param {number} x1, y1 - First point (normalized)
     * @param {number} x2, y2 - Second point (normalized)
     * @returns {number} Distance in normalized units (relative to reference dimension)
     */
    function normalizedDistance(x1, y1, x2, y2) {
        // Convert to pixel space for proper distance calculation with aspect ratio
        const px1 = fromNormalizedX(x1);
        const py1 = fromNormalizedY(y1);
        const px2 = fromNormalizedX(x2);
        const py2 = fromNormalizedY(y2);
        const pixelDist = Math.sqrt((px2 - px1) ** 2 + (py2 - py1) ** 2);
        return pixelDist / getReferenceDimension();
    }

    /**
     * Calculates distance between two points (pixel coordinates)
     * @param {number} x1, y1 - First point
     * @param {number} x2, y2 - Second point
     * @returns {number} Distance in pixels
     */
    function distance(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
    }

    /**
     * Generates a random number between min and max
     * @param {number} min - Minimum value
     * @param {number} max - Maximum value
     * @returns {number} Random value in range
     */
    function randomRange(min, max) {
        return Math.random() * (max - min) + min;
    }

    /**
     * Point-in-polygon test using ray casting algorithm
     * Used for collision detection with irregular asteroid shapes
     * @param {object} point - {x, y} coordinates
     * @param {array} vertices - Array of {x, y} polygon vertices
     * @returns {boolean} True if point is inside polygon
     */
    function pointInPolygon(point, vertices) {
        let inside = false;
        const n = vertices.length;
        
        for (let i = 0, j = n - 1; i < n; j = i++) {
            const xi = vertices[i].x, yi = vertices[i].y;
            const xj = vertices[j].x, yj = vertices[j].y;
            
            // Check if ray from point crosses this edge
            if (((yi > point.y) !== (yj > point.y)) &&
                (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi)) {
                inside = !inside;
            }
        }
        
        return inside;
    }

    /**
     * Circle-to-polygon collision detection
     * Tests if a circle intersects with a polygon
     * @param {object} circle - {x, y, radius}
     * @param {array} vertices - Array of {x, y} polygon vertices
     * @returns {boolean} True if collision detected
     */
    function circlePolygonCollision(circle, vertices) {
        // First check if circle center is inside polygon
        if (pointInPolygon({x: circle.x, y: circle.y}, vertices)) {
            return true;
        }
        
        // Then check if circle intersects any polygon edge
        const n = vertices.length;
        for (let i = 0; i < n; i++) {
            const v1 = vertices[i];
            const v2 = vertices[(i + 1) % n];
            
            // Find closest point on edge to circle center
            const edgeX = v2.x - v1.x;
            const edgeY = v2.y - v1.y;
            const edgeLength = Math.sqrt(edgeX * edgeX + edgeY * edgeY);
            
            // Normalize edge vector
            const edgeNormX = edgeX / edgeLength;
            const edgeNormY = edgeY / edgeLength;
            
            // Vector from v1 to circle center
            const toCircleX = circle.x - v1.x;
            const toCircleY = circle.y - v1.y;
            
            // Project onto edge
            let projection = toCircleX * edgeNormX + toCircleY * edgeNormY;
            projection = Math.max(0, Math.min(edgeLength, projection));
            
            // Closest point on edge
            const closestX = v1.x + edgeNormX * projection;
            const closestY = v1.y + edgeNormY * projection;
            
            // Check distance from closest point to circle center
            if (distance(closestX, closestY, circle.x, circle.y) <= circle.radius) {
                return true;
            }
        }
        
        return false;
    }

    // ============================================
    // SECTION 3: GAME ENTITY CLASSES
    // Ship, Asteroid, and Bullet definitions
    // All positions/velocities stored in normalized coordinates (0-1)
    // ============================================

    /**
     * Ship Class
     * The player-controlled spacecraft
     * All positions and velocities are normalized (0-1 range)
     */
    class Ship {
        constructor(x, y) {
            this.x = x;                    // Normalized X position (0-1)
            this.y = y;                    // Normalized Y position (0-1)
            this.angle = -Math.PI / 2;     // Facing up initially
            this.velocityX = 0;            // Normalized horizontal velocity (per second)
            this.velocityY = 0;            // Normalized vertical velocity (per second)
            this.thrusting = false;        // Is thrust active?
            this.invulnerable = 0;         // Invulnerability frames remaining
            this.shootCooldown = 0;        // Frames until can shoot again
        }

        /**
         * Update ship state based on physics and input
         * Velocity is in reference-dimension per second, converted with aspect ratio
         * @param {number} dt - Delta time multiplier (1.0 = 60fps)
         */
        update(dt = 1) {
            // Apply friction to slow down gradually (adjust for delta time)
            const friction = Math.pow(CONFIG.SHIP_FRICTION, dt);
            this.velocityX *= friction;
            this.velocityY *= friction;
            
            // Apply thrust in facing direction (normalized acceleration)
            if (this.thrusting) {
                this.velocityX += Math.cos(this.angle) * CONFIG.SHIP_THRUST * dt;
                this.velocityY += Math.sin(this.angle) * CONFIG.SHIP_THRUST * dt;
            }
            
            // Limit to max speed (in reference-dimension per second)
            const speed = Math.sqrt(this.velocityX ** 2 + this.velocityY ** 2);
            if (speed > CONFIG.SHIP_MAX_SPEED) {
                this.velocityX = (this.velocityX / speed) * CONFIG.SHIP_MAX_SPEED;
                this.velocityY = (this.velocityY / speed) * CONFIG.SHIP_MAX_SPEED;
            }
            
            // Update position using aspect-ratio-aware conversion
            // This ensures consistent visual speed regardless of viewport dimensions
            this.x += velocityToNormalizedDeltaX(this.velocityX) * dt;
            this.y += velocityToNormalizedDeltaY(this.velocityY) * dt;
            
            // Wrap around normalized space (0-1)
            this.x = wrapNormalized(this.x);
            this.y = wrapNormalized(this.y);
            
            // Decrement timers (adjusted for delta time)
            if (this.invulnerable > 0) this.invulnerable -= dt;
            if (this.shootCooldown > 0) this.shootCooldown -= dt;
        }

        /**
         * Get the ship's triangle vertices in pixel coordinates for rendering
         * Converts from normalized position to pixels
         * @returns {array} Array of {x, y} vertices in pixels
         */
        getVertices() {
            const pixelX = fromNormalizedX(this.x);
            const pixelY = fromNormalizedY(this.y);
            const size = fromNormalizedSize(CONFIG.SHIP_SIZE);
            return [
                // Nose (front point)
                {
                    x: pixelX + Math.cos(this.angle) * size,
                    y: pixelY + Math.sin(this.angle) * size
                },
                // Left wing
                {
                    x: pixelX + Math.cos(this.angle + Math.PI * 0.8) * size * 0.7,
                    y: pixelY + Math.sin(this.angle + Math.PI * 0.8) * size * 0.7
                },
                // Right wing
                {
                    x: pixelX + Math.cos(this.angle - Math.PI * 0.8) * size * 0.7,
                    y: pixelY + Math.sin(this.angle - Math.PI * 0.8) * size * 0.7
                }
            ];
        }

        /**
         * Draw the ship using vector lines
         * @param {CanvasRenderingContext2D} ctx - Canvas context
         */
        draw(ctx) {
            // Skip drawing if blinking during invulnerability
            if (this.invulnerable > 0 && 
                Math.floor(this.invulnerable / CONFIG.INVULN_BLINK_RATE) % 2 === 0) {
                return;
            }
            
            const vertices = this.getVertices();
            const pixelX = fromNormalizedX(this.x);
            const pixelY = fromNormalizedY(this.y);
            const size = fromNormalizedSize(CONFIG.SHIP_SIZE);
            
            // Draw ship triangle
            ctx.strokeStyle = CONFIG.STROKE_COLOR;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            ctx.lineTo(vertices[1].x, vertices[1].y);
            ctx.lineTo(vertices[2].x, vertices[2].y);
            ctx.closePath();
            ctx.stroke();
            
            // Draw thrust flame when accelerating
            if (this.thrusting) {
                ctx.strokeStyle = CONFIG.THRUST_COLOR;
                ctx.beginPath();
                
                // Flame base points (between wings)
                const flameBase1 = {
                    x: pixelX + Math.cos(this.angle + Math.PI * 0.9) * size * 0.4,
                    y: pixelY + Math.sin(this.angle + Math.PI * 0.9) * size * 0.4
                };
                const flameBase2 = {
                    x: pixelX + Math.cos(this.angle - Math.PI * 0.9) * size * 0.4,
                    y: pixelY + Math.sin(this.angle - Math.PI * 0.9) * size * 0.4
                };
                
                // Flame tip (flickers randomly)
                const flameLength = size * (0.8 + Math.random() * 0.4);
                const flameTip = {
                    x: pixelX + Math.cos(this.angle + Math.PI) * flameLength,
                    y: pixelY + Math.sin(this.angle + Math.PI) * flameLength
                };
                
                ctx.moveTo(flameBase1.x, flameBase1.y);
                ctx.lineTo(flameTip.x, flameTip.y);
                ctx.lineTo(flameBase2.x, flameBase2.y);
                ctx.stroke();
            }
        }

        /**
         * Fire a bullet from the ship's nose
         * @returns {Bullet|null} New bullet or null if on cooldown
         */
        shoot() {
            if (this.shootCooldown > 0) return null;
            
            this.shootCooldown = CONFIG.SHOOT_COOLDOWN;
            
            // Play fire sound
            AudioSystem.playFire();
            
            // Get nose position in normalized coords
            // Use aspect-ratio-aware conversion for the offset
            const noseX = this.x + Math.cos(this.angle) * sizeToNormalizedX(CONFIG.SHIP_SIZE);
            const noseY = this.y + Math.sin(this.angle) * sizeToNormalizedY(CONFIG.SHIP_SIZE);
            
            return new Bullet(
                noseX,
                noseY,
                Math.cos(this.angle) * CONFIG.BULLET_SPEED,
                Math.sin(this.angle) * CONFIG.BULLET_SPEED
            );
        }

        /**
         * Reset ship to center of gameplay area (normalized: 0.5, 0.5)
         */
        reset() {
            this.x = 0.5;
            this.y = 0.5;
            this.angle = -Math.PI / 2;
            this.velocityX = 0;
            this.velocityY = 0;
            this.invulnerable = CONFIG.INVULNERABILITY_TIME;
        }
    }

    /**
     * Asteroid Class
     * Space rocks that the player must destroy
     * Position is normalized (0-1), radius/velocity are in reference-dimension units
     */
    class Asteroid {
        constructor(x, y, radius, velocityX, velocityY) {
            this.x = x;                    // Normalized X position (0-1)
            this.y = y;                    // Normalized Y position (0-1)
            this.radius = radius;          // Normalized size (relative to ref dimension)
            this.velocityX = velocityX;    // Velocity in reference-dimension per second
            this.velocityY = velocityY;    // Velocity in reference-dimension per second
            this.angle = Math.random() * Math.PI * 2;  // Random rotation
            this.rotationSpeed = randomRange(-0.02, 0.02);  // Spin rate
            this.vertices = this.generateShape();  // Irregular polygon (normalized)
        }

        /**
         * Generate an irregular polygon shape
         * Creates the classic jagged asteroid look
         * @returns {array} Array of vertices with angle and distance (normalized)
         */
        generateShape() {
            const vertices = [];
            const vertexCount = CONFIG.ASTEROID_VERTICES;
            
            for (let i = 0; i < vertexCount; i++) {
                const angle = (i / vertexCount) * Math.PI * 2;
                // Vary radius for jagged appearance
                const variance = 1 - CONFIG.ASTEROID_JAGGEDNESS + 
                                 Math.random() * CONFIG.ASTEROID_JAGGEDNESS * 2;
                vertices.push({
                    angle: angle,
                    distance: this.radius * variance  // Normalized distance
                });
            }
            
            return vertices;
        }

        /**
         * Get vertices in pixel coordinates for rendering and collision
         * @returns {array} Array of {x, y} pixel coordinates
         */
        getWorldVertices() {
            const pixelX = fromNormalizedX(this.x);
            const pixelY = fromNormalizedY(this.y);
            const ref = getReferenceDimension();
            
            // Check if cached result is still valid
            if (this._cachedVerts && 
                this._cacheX === pixelX && 
                this._cacheY === pixelY && 
                this._cacheAngle === this.angle &&
                this._cacheRef === ref) {
                return this._cachedVerts;
            }
            
            // Calculate and cache - convert normalized distances to pixels
            this._cachedVerts = this.vertices.map(v => ({
                x: pixelX + Math.cos(v.angle + this.angle) * v.distance * ref,
                y: pixelY + Math.sin(v.angle + this.angle) * v.distance * ref
            }));
            this._cacheX = pixelX;
            this._cacheY = pixelY;
            this._cacheAngle = this.angle;
            this._cacheRef = ref;
            
            return this._cachedVerts;
        }

        /**
         * Update asteroid position and rotation
         * Velocity is in reference-dimension per second, converted with aspect ratio
         * @param {number} dt - Delta time multiplier (1.0 = 60fps)
         */
        update(dt = 1) {
            // Move asteroid using aspect-ratio-aware conversion
            this.x += velocityToNormalizedDeltaX(this.velocityX) * dt;
            this.y += velocityToNormalizedDeltaY(this.velocityY) * dt;
            
            // Rotate
            this.angle += this.rotationSpeed * dt;
            
            // Wrap around normalized space (0-1)
            this.x = wrapNormalized(this.x);
            this.y = wrapNormalized(this.y);
        }

        /**
         * Draw asteroid as a vector polygon
         * @param {CanvasRenderingContext2D} ctx - Canvas context
         */
        draw(ctx) {
            const worldVerts = this.getWorldVertices();
            
            ctx.strokeStyle = CONFIG.STROKE_COLOR;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(worldVerts[0].x, worldVerts[0].y);
            
            for (let i = 1; i < worldVerts.length; i++) {
                ctx.lineTo(worldVerts[i].x, worldVerts[i].y);
            }
            
            ctx.closePath();
            ctx.stroke();
        }

        /**
         * Get points awarded for destroying this asteroid
         * Smaller astervoids = more points (using normalized thresholds)
         * @returns {number} Point value
         */
        getPoints() {
            if (this.radius >= CONFIG.ASTEROID_LARGE_THRESHOLD) return CONFIG.POINTS_LARGE;
            if (this.radius >= CONFIG.ASTEROID_MEDIUM_THRESHOLD) return CONFIG.POINTS_MEDIUM;
            return CONFIG.POINTS_SMALL;
        }
    }

    /**
     * Bullet Class
     * Projectiles fired by the ship
     * Position is normalized (0-1), velocity is in reference-dimension per second
     */
    class Bullet {
        constructor(x, y, velocityX, velocityY) {
            this.x = x;                    // Normalized X position (0-1)
            this.y = y;                    // Normalized Y position (0-1)
            this.velocityX = velocityX;    // Velocity in reference-dimension per second
            this.velocityY = velocityY;    // Velocity in reference-dimension per second
            this.lifetime = CONFIG.BULLET_LIFETIME;  // Frames until expiry
        }

        /**
         * Update bullet position and lifetime
         * @param {number} dt - Delta time multiplier (1.0 = 60fps)
         */
        update(dt = 1) {
            // Move bullet using aspect-ratio-aware conversion
            this.x += velocityToNormalizedDeltaX(this.velocityX) * dt;
            this.y += velocityToNormalizedDeltaY(this.velocityY) * dt;
            
            // Wrap around normalized space (0-1)
            this.x = wrapNormalized(this.x);
            this.y = wrapNormalized(this.y);
            
            // Decrement lifetime (adjusted for delta time)
            this.lifetime -= dt;
        }

        /**
         * Draw bullet as a small circle
         * @param {CanvasRenderingContext2D} ctx - Canvas context
         */
        draw(ctx) {
            const pixelX = fromNormalizedX(this.x);
            const pixelY = fromNormalizedY(this.y);
            const pixelRadius = fromNormalizedSize(CONFIG.BULLET_RADIUS);
            
            ctx.strokeStyle = CONFIG.STROKE_COLOR;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(pixelX, pixelY, pixelRadius, 0, Math.PI * 2);
            ctx.stroke();
        }

        /**
         * Check if bullet has expired
         * @returns {boolean} True if bullet should be removed
         */
        isExpired() {
            return this.lifetime <= 0;
        }
    }

    // ============================================
    // SECTION 4: GAME STATE
    // Variables tracking current game status
    // ============================================

    // Canvas and context references
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // HUD element references
    const scoreDisplay = document.getElementById('score');
    const waveDisplay = document.getElementById('wave');
    const livesDisplay = document.getElementById('lives');

    // Game state object
    const game = {
        ship: null,           // Player ship instance
        astervoids: [],        // Active astervoids
        bullets: [],          // Active bullets
        score: 0,             // Current score
        lives: 0,             // Remaining lives
        wave: 0,              // Current wave number
        state: 'start',       // 'start', 'playing', 'respawning', 'gameover', 'waveDelay', 'paused'
        waveDelayTimer: 0,    // Countdown for wave transition
        speedMultiplier: 1,   // Current speed scaling
        previousState: null,  // State before pausing (to resume correctly)
        lastFrameTime: 0,     // Timestamp of last frame for delta time
        mode: 'solo',         // 'solo' or 'session'
        sessionInfo: null,    // Current session details when in session mode
        // Viewport for constrained aspect ratio in session mode
        viewport: {
            x: 0,             // X offset of gameplay area within canvas
            y: 0,             // Y offset of gameplay area within canvas
            width: 0,         // Width of gameplay area (set in resizeCanvas)
            height: 0         // Height of gameplay area (set in resizeCanvas)
        }
    };
    
    // Helper to check if in session mode
    function isSessionMode() {
        return game.mode === 'session';
    }

    // Pause menu element reference
    const pauseMenu = document.getElementById('pause-menu');
    
    // Start screen element reference
    const startScreen = document.getElementById('start-screen');

    // Input tracking
    const keys = {};
    
    // Touch input tracking (mirrors keys for mobile)
    const touch = {
        left: false,
        right: false,
        thrust: false,
        fire: false
    };
    
    // Unified input helpers
    const input = {
        left: () => keys['ArrowLeft'] || keys['KeyA'] || touch.left,
        right: () => keys['ArrowRight'] || keys['KeyD'] || touch.right,
        thrust: () => keys['ArrowUp'] || keys['KeyW'] || touch.thrust,
        fire: () => keys['Space'] || touch.fire
    };

    // ============================================
    // SECTION 5: GAME FUNCTIONS
    // Core game logic and mechanics
    // ============================================

    /**
     * Initialize or reset the game to starting state
     * Ship starts at center (normalized 0.5, 0.5)
     */
    function init() {
        game.ship = new Ship(0.5, 0.5);  // Center in normalized coords
        game.astervoids = [];
        game.bullets = [];
        game.score = 0;
        game.lives = CONFIG.STARTING_LIVES;
        game.wave = 0;
        game.state = 'playing';
        game.speedMultiplier = 1;
        
        // Hide start screen
        startScreen.classList.add('hidden');
        
        // Initialize audio system
        AudioSystem.init();
        AudioSystem.resume();
        
        // Start background beat
        AudioSystem.beat.stop();
        AudioSystem.beat.start();
        
        // Start first wave
        spawnWave();
        
        updateHUD();
    }
    
    /**
     * Start game from start screen
     */
    function startGame() {
        if (game.state === 'start') {
            init();
        }
    }

    /**
     * Spawn a new wave of astervoids
     * Astervoids spawn away from the ship
     */
    function spawnWave() {
        game.wave++;
        
        // Calculate number of astervoids for this wave
        const asteroidCount = CONFIG.ASTEROID_BASE_COUNT + 
                              (game.wave - 1) * CONFIG.WAVE_ASTEROID_INCREMENT;
        
        // Increase speed multiplier (capped)
        game.speedMultiplier = Math.min(
            CONFIG.MAX_SPEED_MULTIPLIER,
            1 + (game.wave - 1) * (CONFIG.WAVE_SPEED_MULTIPLIER - 1)
        );
        
        // Spawn astervoids at random positions away from ship
        for (let i = 0; i < asteroidCount; i++) {
            spawnAsteroidAwayFromShip();
        }
        
        updateHUD();
    }

    /**
     * Spawn a single asteroid at a safe distance from the ship
     * Uses normalized coordinates (0-1 range)
     */
    function spawnAsteroidAwayFromShip() {
        let x, y;
        
        // Keep trying until we find a safe spawn point (all in normalized coords)
        do {
            x = Math.random();  // 0-1
            y = Math.random();  // 0-1
        } while (normalizedDistance(x, y, game.ship.x, game.ship.y) < CONFIG.SPAWN_MIN_DISTANCE);
        
        // Random velocity direction
        const angle = Math.random() * Math.PI * 2;
        const speed = (CONFIG.ASTEROID_BASE_SPEED + 
                       Math.random() * CONFIG.ASTEROID_SPEED_VARIANCE) * 
                      game.speedMultiplier;
        
        game.astervoids.push(new Asteroid(
            x, y,
            CONFIG.INITIAL_ASTEROID_RADIUS,
            Math.cos(angle) * speed,
            Math.sin(angle) * speed
        ));
    }

    /**
     * Split an asteroid into two smaller pieces
     * Implements conservation of area (mass) and energy
     * All values are in normalized coordinates
     * @param {Asteroid} asteroid - The asteroid to split
     */
    function splitAsteroid(asteroid) {
        // Add points
        game.score += asteroid.getPoints();
        
        // Play explosion sound based on asteroid size (using normalized thresholds)
        const size = asteroid.radius >= CONFIG.ASTEROID_LARGE_THRESHOLD ? 'large' : 
                     asteroid.radius >= CONFIG.ASTEROID_MEDIUM_THRESHOLD ? 'medium' : 'small';
        AudioSystem.playExplosion(size);
        
        // Don't split if too small
        if (asteroid.radius <= CONFIG.MIN_ASTEROID_RADIUS) {
            return;  // Asteroid is destroyed, no children spawned
        }
        
        // Calculate child sizes using area conservation
        // Area ∝ r², so r1² + r2² = R² for conservation
        // We use splitRatio to determine how area is divided
        const splitRatio = randomRange(CONFIG.MIN_SPLIT_RATIO, 1 - CONFIG.MIN_SPLIT_RATIO);
        
        // Calculate child radii: r = R * sqrt(ratio)
        const radius1 = asteroid.radius * Math.sqrt(splitRatio);
        const radius2 = asteroid.radius * Math.sqrt(1 - splitRatio);
        
        // Calculate parent's kinetic energy (E = 0.5 * mass * v²)
        // Mass is proportional to area (r²), so E ∝ r² * v²
        const parentSpeed = Math.sqrt(asteroid.velocityX ** 2 + asteroid.velocityY ** 2);
        const parentEnergy = asteroid.radius ** 2 * parentSpeed ** 2;
        
        // Only spawn children that are above minimum size
        const children = [];
        
        if (radius1 >= CONFIG.MIN_ASTEROID_RADIUS) {
            children.push(radius1);
        }
        if (radius2 >= CONFIG.MIN_ASTEROID_RADIUS) {
            children.push(radius2);
        }
        
        // Calculate total mass of surviving children for energy distribution
        const totalChildMass = children.reduce((sum, r) => sum + r ** 2, 0);
        
        // Spawn child astervoids with energy conservation
        children.forEach((childRadius, index) => {
            // Perpendicular direction to original velocity (spreads children apart)
            const spreadAngle = Math.atan2(asteroid.velocityY, asteroid.velocityX) + 
                               (index === 0 ? Math.PI / 2 : -Math.PI / 2);
            
            // Energy conservation: each piece gets energy proportional to its mass
            // E_child = E_parent * (r_child² / totalChildMass)
            // Since E = m * v² and m ∝ r², we have: r² * v² = E_child
            // Therefore: v = sqrt(E_child / r²)
            const childMass = childRadius ** 2;
            const childEnergy = parentEnergy * (childMass / totalChildMass);
            const childSpeed = Math.sqrt(childEnergy / childMass);
            
            const angle = spreadAngle + randomRange(-0.5, 0.5);
            
            game.astervoids.push(new Asteroid(
                asteroid.x,
                asteroid.y,
                childRadius,
                Math.cos(angle) * childSpeed,
                Math.sin(angle) * childSpeed
            ));
        });
        
        updateHUD();
    }

    /**
     * Toggle pause state (disabled in session mode)
     */
    function togglePause() {
        // Pause is disabled in session mode
        if (isSessionMode()) return;

        if (game.state === 'paused') {
            // Resume game
            game.state = game.previousState || 'playing';
            game.previousState = null;
            game.lastFrameTime = 0; // Reset to prevent delta time jump
            pauseMenu.classList.remove('visible');
            // Resume background beat
            AudioSystem.beat.start();
        } else if (game.state === 'playing' || game.state === 'waveDelay') {
            // Pause game
            game.previousState = game.state;
            game.state = 'paused';
            pauseMenu.classList.add('visible');
            // Stop ship thrust visual/sound when pausing
            if (game.ship) game.ship.thrusting = false;
            AudioSystem.thrustSound.stop();
            // Pause background beat
            AudioSystem.beat.stop();
        }
    }

    /**
     * Handle player input each frame
     * @param {number} dt - Delta time multiplier (1.0 = 60fps)
     */
    function handleInput(dt = 1) {
        if (game.state === 'start') {
            // Session picker handles start - don't process Enter here
            return;
        }
        
        if (game.state === 'gameover') {
            // Check for restart/return to menu
            if (keys['Enter']) {
                if (isSessionMode()) {
                    // Return to start screen for session mode
                    returnToStartScreen();
                } else {
                    // Restart for solo mode
                    init();
                }
            }
            return;
        }

        if (game.state === 'paused') {
            // Allow restart from pause menu (solo only, session can't pause)
            if (keys['Enter']) {
                pauseMenu.classList.remove('visible');
                returnToStartScreen();
            }
            return;
        }
        
        if (game.state !== 'playing' && game.state !== 'waveDelay') return;
        
        // Rotation (adjusted for delta time)
        if (input.left()) {
            game.ship.angle -= CONFIG.SHIP_TURN_SPEED * dt;
        }
        if (input.right()) {
            game.ship.angle += CONFIG.SHIP_TURN_SPEED * dt;
        }
        
        // Thrust
        const wasThrusting = game.ship.thrusting;
        game.ship.thrusting = input.thrust();
        
        // Handle thrust sound
        if (game.ship.thrusting && !wasThrusting) {
            AudioSystem.thrustSound.start();
        } else if (!game.ship.thrusting && wasThrusting) {
            AudioSystem.thrustSound.stop();
        }
        
        // Shoot
        if (input.fire() && game.bullets.length < CONFIG.MAX_BULLETS) {
            const bullet = game.ship.shoot();
            if (bullet) {
                game.bullets.push(bullet);
            }
        }
    }

    /**
     * Check all collisions between game entities
     * All collision checks work in pixel coordinates
     */
    function checkCollisions() {
        // Bullet vs Asteroid collisions
        for (let i = game.bullets.length - 1; i >= 0; i--) {
            const bullet = game.bullets[i];
            
            for (let j = game.astervoids.length - 1; j >= 0; j--) {
                const asteroid = game.astervoids[j];
                
                // Circle-to-polygon collision for bullet vs asteroid (in pixel coords)
                const bulletCircle = {
                    x: fromNormalizedX(bullet.x),
                    y: fromNormalizedY(bullet.y),
                    radius: fromNormalizedSize(CONFIG.BULLET_RADIUS)
                };
                
                if (circlePolygonCollision(bulletCircle, asteroid.getWorldVertices())) {
                    // Remove bullet
                    game.bullets.splice(i, 1);
                    
                    // Remove asteroid and potentially spawn children
                    game.astervoids.splice(j, 1);
                    splitAsteroid(asteroid);
                    
                    break;  // Bullet can only hit one asteroid
                }
            }
        }
        
        // Ship vs Asteroid collisions (only if not invulnerable)
        if (game.ship.invulnerable <= 0 && game.state === 'playing') {
            const shipVertices = game.ship.getVertices();  // Already in pixel coords
            
            for (const asteroid of game.astervoids) {
                const asteroidVerts = asteroid.getWorldVertices();  // Already in pixel coords
                
                // Check if any ship vertex is inside asteroid
                for (const vertex of shipVertices) {
                    if (pointInPolygon(vertex, asteroidVerts)) {
                        handleShipHit();
                        return;
                    }
                }
                
                // Check if any asteroid vertex is inside ship triangle
                for (const vertex of asteroidVerts) {
                    if (pointInPolygon(vertex, shipVertices)) {
                        handleShipHit();
                        return;
                    }
                }
            }
        }
    }

    /**
     * Handle ship being hit by asteroid
     */
    function handleShipHit() {
        game.lives--;
        updateHUD();
        
        // Play ship explosion sound
        AudioSystem.playShipExplosion();
        
        // Stop thrust sound if playing
        AudioSystem.thrustSound.stop();
        
        if (game.lives <= 0) {
            game.state = 'gameover';
            // Stop background beat on game over
            AudioSystem.beat.stop();
            
            // In session mode, leave the session on game over
            if (isSessionMode() && SessionClient.isConnected()) {
                SessionClient.leaveSession().catch(console.error);
            }
        } else {
            // Respawn ship at center with invulnerability
            game.ship.reset();
        }
    }

    /**
     * Update HUD display elements
     */
    function updateHUD() {
        scoreDisplay.textContent = `Score: ${game.score}`;
        waveDisplay.textContent = `Wave: ${game.wave}`;
        livesDisplay.textContent = `Lives: ${game.lives}`;
        
        // Update session indicator
        const sessionIndicator = document.getElementById('session-indicator');
        if (sessionIndicator) {
            if (isSessionMode() && game.sessionInfo) {
                sessionIndicator.textContent = `🎮 ${game.sessionInfo.name}`;
                sessionIndicator.style.display = '';
            } else {
                sessionIndicator.textContent = '';
                sessionIndicator.style.display = 'none';
            }
        }
    }

    /**
     * Draw centered text message on screen
     * Uses gameplay width for centering (works with viewport transform)
     * @param {string} text - Message to display
     * @param {number} y - Y position (in gameplay coordinates)
     * @param {number} size - Font size
     */
    function drawCenteredText(text, y, size = 32) {
        ctx.fillStyle = CONFIG.STROKE_COLOR;
        ctx.font = `${size}px 'Courier New', monospace`;
        ctx.textAlign = 'center';
        ctx.fillText(text, getGameWidth() / 2, y);
    }

    // ============================================
    // SECTION 6: GAME LOOP
    // Main update and render cycle
    // ============================================

    /**
     * Main game loop - called every frame
     * @param {number} timestamp - Current time from requestAnimationFrame
     */
    function gameLoop(timestamp) {
        // Calculate delta time (normalized to 60fps: dt=1.0 at 60fps, dt=0.5 at 120fps)
        if (!game.lastFrameTime) game.lastFrameTime = timestamp;
        const elapsed = timestamp - game.lastFrameTime;
        game.lastFrameTime = timestamp;
        
        // Calculate delta time multiplier (1.0 = one frame at 60fps = 16.67ms)
        const targetFrameTime = 1000 / CONFIG.TARGET_FPS;
        const dt = Math.min(elapsed / targetFrameTime, 3); // Cap at 3x to prevent huge jumps
        
        // --- UPDATE PHASE ---
        
        // Handle player input
        handleInput(dt);
        
        // Update astervoids during start screen for visual effect
        if (game.state === 'start') {
            game.astervoids.forEach(asteroid => asteroid.update(dt));
        }
        
        // Update game state based on current state
        if (game.state === 'playing' || game.state === 'waveDelay') {
            // Update ship
            game.ship.update(dt);
            
            // Update astervoids
            game.astervoids.forEach(asteroid => asteroid.update(dt));
            
            // Update bullets and remove expired ones
            game.bullets = game.bullets.filter(bullet => {
                bullet.update(dt);
                return !bullet.isExpired();
            });
            
            // Check collisions
            checkCollisions();
            
            // Check for wave completion
            if (game.astervoids.length === 0 && game.state === 'playing') {
                game.state = 'waveDelay';
                game.waveDelayTimer = CONFIG.WAVE_DELAY;
            }
            
            // Handle wave delay countdown (adjusted for delta time)
            if (game.state === 'waveDelay') {
                game.waveDelayTimer -= dt;
                if (game.waveDelayTimer <= 0) {
                    spawnWave();
                    game.state = 'playing';
                    AudioSystem.playNewWave();
                }
            }
            
            // Update background beat tempo based on asteroid count
            const maxAstervoids = CONFIG.ASTEROID_BASE_COUNT + (game.wave - 1) * CONFIG.WAVE_ASTEROID_INCREMENT;
            const totalAsteroidArea = game.astervoids.reduce((sum, a) => sum + a.radius * a.radius, 0);
            const maxArea = maxAstervoids * CONFIG.INITIAL_ASTEROID_RADIUS * CONFIG.INITIAL_ASTEROID_RADIUS;
            AudioSystem.beat.updateTempo(totalAsteroidArea, maxArea);
        }
        
        // --- RENDER PHASE ---
        
        // Clear entire canvas with black
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // In session mode with constrained viewport, apply transform and clipping
        const hasViewportOffset = game.viewport.x > 0 || game.viewport.y > 0;
        if (hasViewportOffset) {
            ctx.save();
            
            // Clip to viewport area
            ctx.beginPath();
            ctx.rect(game.viewport.x, game.viewport.y, game.viewport.width, game.viewport.height);
            ctx.clip();
            
            // Translate so gameplay coordinates (0,0) start at viewport origin
            ctx.translate(game.viewport.x, game.viewport.y);
        }
        
        // Draw game entities (now in gameplay coordinates)
        game.astervoids.forEach(asteroid => asteroid.draw(ctx));
        game.bullets.forEach(bullet => bullet.draw(ctx));
        if (game.state !== 'start') {
            game.ship.draw(ctx);
        }
        
        // Draw state-specific overlays (in gameplay coordinates)
        if (game.state === 'waveDelay') {
            drawCenteredText(`WAVE ${game.wave + 1}`, getGameHeight() / 2, 48);
        }
        
        if (game.state === 'gameover') {
            drawCenteredText('GAME OVER', getGameHeight() / 2 - 40, 48);
            drawCenteredText(`Final Score: ${game.score}`, getGameHeight() / 2 + 10, 24);
            if (!touchControlsEnabled) {
                // Show different message based on mode
                if (isSessionMode()) {
                    drawCenteredText('Press ENTER for menu', getGameHeight() / 2 + 50, 20);
                } else {
                    drawCenteredText('Press ENTER to restart', getGameHeight() / 2 + 50, 20);
                }
            }
        }
        
        // Restore context if we applied viewport transform
        if (hasViewportOffset) {
            ctx.restore();
            
            // Draw white border around viewport (outside the clipping region)
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(game.viewport.x, game.viewport.y, game.viewport.width, game.viewport.height);
        }
        
        // Request next frame
        requestAnimationFrame(gameLoop);
    }

    // ============================================
    // SECTION 7: EVENT LISTENERS & INITIALIZATION
    // Set up input handling and start the game
    // ============================================

    // Track key presses
    document.addEventListener('keydown', (e) => {
        keys[e.code] = true;
        
        // Initialize and resume audio on first user interaction
        AudioSystem.init();
        AudioSystem.resume();
        
        // Prevent default for game keys (stops page scrolling)
        if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
            e.preventDefault();
        }

        // Toggle pause with Escape or P (only handle once per press)
        if ((e.code === 'Escape' || e.code === 'KeyP') && game.state !== 'gameover') {
            togglePause();
            e.preventDefault();
        }
    });

    document.addEventListener('keyup', (e) => {
        keys[e.code] = false;
    });

    // Prevent focus loss from affecting input - auto pause
    window.addEventListener('blur', () => {
        // Clear all keys when window loses focus
        Object.keys(keys).forEach(key => keys[key] = false);
        if (game.ship) game.ship.thrusting = false;
        AudioSystem.thrustSound.stop();
        
        // Auto-pause when window loses focus (only on desktop)
        if (!touchControlsEnabled && (game.state === 'playing' || game.state === 'waveDelay')) {
            togglePause();
        }
    });

    // ============================================
    // SECTION 8: MOBILE TOUCH CONTROLS
    // Touch input handling for mobile devices
    // ============================================

    // Only enable touch controls when user actually touches the screen
    // (not just when touch capability is detected, as many laptops have touch screens)
    let touchControlsEnabled = false;
    
    function enableTouchControls() {
        if (!touchControlsEnabled) {
            touchControlsEnabled = true;
            document.getElementById('game-container').classList.add('touch-enabled');
        }
    }

    // Touch control elements
    const touchButtons = {
        left: document.getElementById('touch-left'),
        right: document.getElementById('touch-right'),
        thrust: document.getElementById('touch-thrust'),
        fire: document.getElementById('touch-fire'),
        pause: document.getElementById('touch-pause'),
        restart: document.getElementById('touch-restart')
    };

    // Helper to set touch state
    function setTouchState(control, active) {
        touch[control] = active;
        if (touchButtons[control]) {
            touchButtons[control].classList.toggle('active', active);
        }
    }

    // Setup touch button handlers
    function setupTouchButton(element, control) {
        if (!element) return;

        element.addEventListener('touchstart', (e) => {
            e.preventDefault();
            // Initialize and resume audio on first touch
            AudioSystem.init();
            AudioSystem.resume();
            setTouchState(control, true);
        }, { passive: false });

        element.addEventListener('touchend', (e) => {
            e.preventDefault();
            setTouchState(control, false);
        }, { passive: false });

        element.addEventListener('touchcancel', (e) => {
            setTouchState(control, false);
        });
    }

    // Initialize touch controls for game buttons
    ['left', 'right', 'thrust', 'fire'].forEach(control => {
        setupTouchButton(touchButtons[control], control);
    });

    // Pause button handler
    if (touchButtons.pause) {
        touchButtons.pause.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (game.state !== 'gameover') {
                togglePause();
            }
        }, { passive: false });
    }

    // Restart button handler (mobile controls)
    if (touchButtons.restart) {
        touchButtons.restart.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (game.state === 'gameover' || game.state === 'paused') {
                pauseMenu.classList.remove('visible');
                touchButtons.restart.classList.remove('visible');
                // Return to menu for session mode, restart for solo
                if (isSessionMode()) {
                    returnToStartScreen();
                } else {
                    init();
                }
            }
        }, { passive: false });
    }

    // Pause menu restart button handler
    const pauseRestartBtn = document.getElementById('pause-restart-btn');
    if (pauseRestartBtn) {
        pauseRestartBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (game.state === 'paused') {
                pauseMenu.classList.remove('visible');
                returnToStartScreen();
            }
        }, { passive: false });
    }

    // Fullscreen button handler
    const fullscreenBtn = document.getElementById('touch-fullscreen');
    if (fullscreenBtn) {
        fullscreenBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const container = document.getElementById('game-container');
            if (document.fullscreenElement) {
                document.exitFullscreen();
            } else if (container.requestFullscreen) {
                container.requestFullscreen();
            } else if (container.webkitRequestFullscreen) {
                container.webkitRequestFullscreen(); // Safari
            }
        }, { passive: false });
    }

    // Track fullscreen state
    document.addEventListener('fullscreenchange', () => {
        document.getElementById('game-container').classList.toggle('fullscreen-active', !!document.fullscreenElement);
        resizeCanvas();
    });

    // Detect standalone mode (Add to Home Screen)
    if (window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone) {
        document.getElementById('game-container').classList.add('standalone-mode');
    }

    // Prevent default touch behaviors on game container (no zooming/scrolling)
    // Also enable touch controls on first touch anywhere on game
    document.getElementById('game-container').addEventListener('touchstart', (e) => {
        enableTouchControls();
        // Don't auto-start on touch - let session picker handle it
        if (e.target.classList.contains('touch-btn') || e.target.closest('#session-picker')) return;
        e.preventDefault();
    }, { passive: false });

    document.getElementById('game-container').addEventListener('touchmove', (e) => {
        e.preventDefault();
    }, { passive: false });

    // ============================================
    // SECTION 9: WINDOW RESIZE HANDLING
    // Dynamic canvas sizing for responsive gameplay
    // ============================================

    // Handle window resize events
    window.addEventListener('resize', () => {
        resizeCanvas();
    });

    // Handle orientation change on mobile devices
    window.addEventListener('orientationchange', () => {
        // Small delay to let the browser finish orientation change
        setTimeout(() => {
            resizeCanvas();
        }, 100);
    });

    // Handle screen resize via visualViewport API (better for mobile keyboards, etc.)
    if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', () => {
            resizeCanvas();
        });
    }

    // Initial canvas sizing before game starts
    resizeCanvas();

    // Initialize game objects for start screen display (but don't start playing)
    // Use normalized coordinates (0.5, 0.5 = center)
    game.ship = new Ship(0.5, 0.5);
    game.astervoids = [];
    game.bullets = [];
    // Spawn some astervoids for visual effect on start screen (normalized coords)
    for (let i = 0; i < CONFIG.START_SCREEN_ASTERVOIDS; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = CONFIG.ASTEROID_BASE_SPEED + Math.random() * CONFIG.ASTEROID_SPEED_VARIANCE;
        game.astervoids.push(new Asteroid(
            Math.random(),  // 0-1 normalized X
            Math.random(),  // 0-1 normalized Y
            CONFIG.INITIAL_ASTEROID_RADIUS,
            Math.cos(angle) * speed,
            Math.sin(angle) * speed
        ));
    }
    
    // Mobile UI update loop (only runs after touch controls are enabled)
    function startMobileUILoop() {
        requestAnimationFrame(function mobileLoop() {
            if (touchButtons.restart) {
                touchButtons.restart.classList.toggle('visible', game.state === 'gameover');
            }
            // Hide pause button in session mode
            if (touchButtons.pause) {
                touchButtons.pause.style.display = isSessionMode() ? 'none' : '';
            }
            requestAnimationFrame(mobileLoop);
        });
    }
    
    // Update enableTouchControls to start mobile UI loop
    const originalEnableTouchControls = enableTouchControls;
    enableTouchControls = function() {
        originalEnableTouchControls();
        startMobileUILoop();
        enableTouchControls = originalEnableTouchControls; // Only start loop once
    };

    // ============================================
    // SECTION 10: SESSION PICKER
    // Multiplayer session management UI
    // ============================================

    const sessionPicker = {
        statusEl: document.getElementById('picker-status'),
        listEl: document.getElementById('session-list'),
        btnJoin: document.getElementById('btn-join'),
        btnCreate: document.getElementById('btn-create'),
        btnSolo: document.getElementById('btn-solo'),
        sessions: [],
        selectedSessionId: null,
        maxSessions: 6,
        canCreate: false,
        refreshInterval: null,
        connected: false
    };

    // Update status message
    function setPickerStatus(message, type = '') {
        sessionPicker.statusEl.textContent = message;
        sessionPicker.statusEl.className = 'picker-status' + (type ? ' ' + type : '');
    }

    // Render session list
    function renderSessionList() {
        const { listEl, sessions, selectedSessionId } = sessionPicker;
        listEl.innerHTML = '';

        if (sessions.length === 0) {
            return; // CSS :empty will show "No sessions available"
        }

        sessions.forEach(session => {
            const isFull = session.memberCount >= session.maxMembers;
            const item = document.createElement('div');
            item.className = 'session-item' + 
                (session.id === selectedSessionId ? ' selected' : '') +
                (isFull ? ' disabled' : '');
            item.dataset.sessionId = session.id;
            item.innerHTML = `
                <span class="session-name">${session.name}</span>
                <span class="session-players">${session.memberCount}/${session.maxMembers}${isFull ? ' FULL' : ''}</span>
            `;
            if (!isFull) {
                item.addEventListener('click', () => selectSession(session.id));
            }
            listEl.appendChild(item);
        });
    }

    // Select a session
    function selectSession(sessionId) {
        sessionPicker.selectedSessionId = sessionId;
        renderSessionList();
        updatePickerButtons();
    }

    // Update button states
    function updatePickerButtons() {
        const { btnJoin, btnCreate, selectedSessionId, sessions, canCreate, connected } = sessionPicker;
        
        // Join button - enabled if connected and a non-full session is selected
        const selectedSession = sessions.find(s => s.id === selectedSessionId);
        const canJoin = connected && selectedSession && selectedSession.memberCount < selectedSession.maxMembers;
        btnJoin.disabled = !canJoin;

        // Create button - enabled if connected and not at max sessions
        btnCreate.disabled = !connected || !canCreate;
        if (!canCreate && connected) {
            btnCreate.title = 'Maximum sessions reached';
        } else {
            btnCreate.title = '';
        }
    }

    // Refresh session list from server
    async function refreshSessionList() {
        if (!SessionClient.isConnected()) return;

        try {
            const result = await SessionClient.getActiveSessions();
            sessionPicker.sessions = result.sessions || [];
            sessionPicker.maxSessions = result.maxSessions;
            sessionPicker.canCreate = result.canCreateSession;

            // Clear selection if selected session no longer exists
            if (sessionPicker.selectedSessionId) {
                const stillExists = sessionPicker.sessions.find(s => s.id === sessionPicker.selectedSessionId);
                if (!stillExists) {
                    sessionPicker.selectedSessionId = null;
                }
            }

            renderSessionList();
            updatePickerButtons();
            setPickerStatus(`${sessionPicker.sessions.length}/${sessionPicker.maxSessions} sessions`);
        } catch (err) {
            console.error('Failed to refresh sessions:', err);
            setPickerStatus('Failed to load sessions', 'error');
        }
    }

    // Connect to session hub
    async function connectToSessionHub() {
        setPickerStatus('Connecting...', 'connecting');

        try {
            const success = await SessionClient.connect();
            if (success) {
                sessionPicker.connected = true;
                await refreshSessionList();
                // Auto-refresh every 5 seconds while on start screen
                sessionPicker.refreshInterval = setInterval(() => {
                    if (game.state === 'start') {
                        refreshSessionList();
                    }
                }, 5000);
            } else {
                throw new Error('Connection failed');
            }
        } catch (err) {
            console.error('Session hub connection failed:', err);
            setPickerStatus('Offline - Solo play only', 'error');
            sessionPicker.connected = false;
            updatePickerButtons();
        }
    }

    // Stop session refresh
    function stopSessionRefresh() {
        if (sessionPicker.refreshInterval) {
            clearInterval(sessionPicker.refreshInterval);
            sessionPicker.refreshInterval = null;
        }
    }

    // Handle join session
    async function handleJoinSession() {
        if (!sessionPicker.selectedSessionId) return;

        const session = sessionPicker.sessions.find(s => s.id === sessionPicker.selectedSessionId);
        if (!session) return;

        setPickerStatus('Joining...', 'connecting');
        sessionPicker.btnJoin.disabled = true;
        sessionPicker.btnCreate.disabled = true;

        try {
            const result = await SessionClient.joinSession(sessionPicker.selectedSessionId);
            if (result) {
                game.mode = 'session';
                game.sessionInfo = {
                    id: result.session.id,
                    name: result.session.name,
                    memberId: result.member.id,
                    role: result.member.role,
                    aspectRatio: result.session.aspectRatio
                };
                stopSessionRefresh();
                startGameFromPicker();
            } else {
                // Session full or other error
                setPickerStatus('Could not join - session may be full', 'error');
                await refreshSessionList();
            }
        } catch (err) {
            console.error('Join session failed:', err);
            setPickerStatus('Failed to join session', 'error');
            await refreshSessionList();
        }
    }

    // Handle create session
    async function handleCreateSession() {
        setPickerStatus('Creating...', 'connecting');
        sessionPicker.btnJoin.disabled = true;
        sessionPicker.btnCreate.disabled = true;

        try {
            // Capture the current aspect ratio at the moment of session creation
            const currentAspectRatio = canvas.width / canvas.height;
            const result = await SessionClient.createSession(currentAspectRatio);
            if (result) {
                game.mode = 'session';
                game.sessionInfo = {
                    id: result.session.id,
                    name: result.session.name,
                    memberId: result.member.id,
                    role: result.member.role,
                    aspectRatio: result.session.aspectRatio
                };
                stopSessionRefresh();
                startGameFromPicker();
            } else {
                setPickerStatus('Could not create - max sessions reached', 'error');
                await refreshSessionList();
            }
        } catch (err) {
            console.error('Create session failed:', err);
            setPickerStatus('Failed to create session', 'error');
            await refreshSessionList();
        }
    }

    // Handle solo play
    function handleSoloPlay() {
        game.mode = 'solo';
        game.sessionInfo = null;
        stopSessionRefresh();
        startGameFromPicker();
    }

    // Start game from picker (replaces old startGame for picker context)
    function startGameFromPicker() {
        if (game.state === 'start') {
            // Recalculate viewport with new session aspect ratio before initializing (force recalc)
            resizeCanvas(true);
            init();
        }
    }

    // Return to start screen
    function returnToStartScreen(errorMessage = null) {
        // Leave session if in one
        if (isSessionMode() && SessionClient.isConnected()) {
            SessionClient.leaveSession().catch(console.error);
        }

        // Reset game mode
        game.mode = 'solo';
        game.sessionInfo = null;

        // Reset game state
        game.state = 'start';
        game.score = 0;
        game.lives = CONFIG.STARTING_LIVES;
        game.wave = 0;
        pauseMenu.classList.remove('visible');
        startScreen.classList.remove('hidden');

        // Stop audio
        AudioSystem.beat.stop();
        AudioSystem.thrustSound.stop();

        // Recalculate viewport now that we're back in solo mode (force recalc even if window size unchanged)
        resizeCanvas(true);

        // Reinitialize start screen visuals (normalized coordinates)
        game.ship = new Ship(0.5, 0.5);
        game.astervoids = [];
        game.bullets = [];
        for (let i = 0; i < CONFIG.START_SCREEN_ASTERVOIDS; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = CONFIG.ASTEROID_BASE_SPEED + Math.random() * CONFIG.ASTEROID_SPEED_VARIANCE;
            game.astervoids.push(new Asteroid(
                Math.random(),  // 0-1 normalized X
                Math.random(),  // 0-1 normalized Y
                CONFIG.INITIAL_ASTEROID_RADIUS,
                Math.cos(angle) * speed,
                Math.sin(angle) * speed
            ));
        }

        // Update picker
        sessionPicker.selectedSessionId = null;
        if (errorMessage) {
            setPickerStatus(errorMessage, 'error');
        }

        // Reconnect and refresh if needed
        if (!SessionClient.isConnected()) {
            connectToSessionHub();
        } else {
            refreshSessionList();
            // Restart refresh interval
            if (!sessionPicker.refreshInterval) {
                sessionPicker.refreshInterval = setInterval(() => {
                    if (game.state === 'start') {
                        refreshSessionList();
                    }
                }, 5000);
            }
        }
    }

    // Setup picker button handlers
    sessionPicker.btnJoin.addEventListener('click', handleJoinSession);
    sessionPicker.btnCreate.addEventListener('click', handleCreateSession);
    sessionPicker.btnSolo.addEventListener('click', handleSoloPlay);

    // Keyboard navigation for session picker
    document.addEventListener('keydown', (e) => {
        if (game.state !== 'start') return;

        const { sessions, selectedSessionId } = sessionPicker;
        const currentIndex = sessions.findIndex(s => s.id === selectedSessionId);

        if (e.code === 'ArrowDown' || e.code === 'KeyS') {
            e.preventDefault();
            // Find next non-full session
            for (let i = currentIndex + 1; i < sessions.length; i++) {
                if (sessions[i].memberCount < sessions[i].maxMembers) {
                    selectSession(sessions[i].id);
                    break;
                }
            }
        } else if (e.code === 'ArrowUp' || e.code === 'KeyW') {
            e.preventDefault();
            // Find previous non-full session
            for (let i = currentIndex - 1; i >= 0; i--) {
                if (sessions[i].memberCount < sessions[i].maxMembers) {
                    selectSession(sessions[i].id);
                    break;
                }
            }
        } else if (e.code === 'Enter') {
            e.preventDefault();
            if (selectedSessionId && !sessionPicker.btnJoin.disabled) {
                handleJoinSession();
            }
        }
    });

    // Session client event handlers
    SessionClient.on('onDisconnected', (error) => {
        sessionPicker.connected = false;
        if (game.state !== 'start') {
            // Mid-game disconnect - return to start screen
            returnToStartScreen('Disconnected from server');
        } else {
            setPickerStatus('Disconnected - reconnecting...', 'error');
            // Try to reconnect after a delay
            setTimeout(connectToSessionHub, 2000);
        }
    });

    // Leave session on page unload
    window.addEventListener('beforeunload', () => {
        if (isSessionMode() && SessionClient.isConnected()) {
            SessionClient.leaveSession();
        }
    });

    // Initialize session connection
    connectToSessionHub();
    
    requestAnimationFrame(gameLoop);  // Use rAF to provide timestamp

    </script>
</body>
</html>
